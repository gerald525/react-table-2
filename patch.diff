From 298d754db7aaf6378c896f9190709dbf30659ae3 Mon Sep 17 00:00:00 2001
From: Kamran Asif <kamran.asif@schrodinger.com>
Date: Mon, 22 Feb 2016 11:42:30 -0500
Subject: [PATCH] Removing transition shim

---
 src/FixedDataTable.react.js                        | 1098 ++++++++++++++++++++
 src/FixedDataTableColumn.react.js                  |  189 ++++
 src/FixedDataTableColumnGroup.react.js             |   78 ++
 src/FixedDataTableColumnGroupNew.react.js          |   78 --
 src/FixedDataTableColumnNew.react.js               |  189 ----
 src/FixedDataTableNew.react.js                     | 1098 --------------------
 src/transition/FixedDataTable.react.js             |  561 ----------
 .../FixedDataTableCellTransition.react.js          |  219 ----
 src/transition/FixedDataTableColumn.react.js       |   37 -
 src/transition/FixedDataTableColumnGroup.react.js  |   37 -
 10 files changed, 1365 insertions(+), 2219 deletions(-)
 create mode 100644 src/FixedDataTable.react.js
 create mode 100644 src/FixedDataTableColumn.react.js
 create mode 100644 src/FixedDataTableColumnGroup.react.js
 delete mode 100644 src/FixedDataTableColumnGroupNew.react.js
 delete mode 100644 src/FixedDataTableColumnNew.react.js
 delete mode 100644 src/FixedDataTableNew.react.js
 delete mode 100644 src/transition/FixedDataTable.react.js
 delete mode 100644 src/transition/FixedDataTableCellTransition.react.js
 delete mode 100644 src/transition/FixedDataTableColumn.react.js
 delete mode 100644 src/transition/FixedDataTableColumnGroup.react.js

diff --git a/src/FixedDataTable.react.js b/src/FixedDataTable.react.js
new file mode 100644
index 0000000..9a756f1
--- /dev/null
+++ b/src/FixedDataTable.react.js
@@ -0,0 +1,1098 @@
+/**
+ * Copyright (c) 2015, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ * @providesModule FixedDataTable.react
+ * @typechecks
+ * @noflow
+ */
+
+/*eslint no-bitwise:1*/
+
+var React = require('React');
+var ReactComponentWithPureRenderMixin = require('ReactComponentWithPureRenderMixin');
+var ReactWheelHandler = require('ReactWheelHandler');
+var Scrollbar = require('Scrollbar.react');
+var FixedDataTableBufferedRows = require('FixedDataTableBufferedRows.react');
+var FixedDataTableColumnResizeHandle = require('FixedDataTableColumnResizeHandle.react');
+var FixedDataTableRow = require('FixedDataTableRow.react');
+var FixedDataTableScrollHelper = require('FixedDataTableScrollHelper');
+var FixedDataTableWidthHelper = require('FixedDataTableWidthHelper');
+
+var cx = require('cx');
+var debounceCore = require('debounceCore');
+var emptyFunction = require('emptyFunction');
+var invariant = require('invariant');
+var joinClasses = require('joinClasses');
+var shallowEqual = require('shallowEqual');
+var translateDOMPositionXY = require('translateDOMPositionXY');
+
+var {PropTypes} = React;
+var ReactChildren = React.Children;
+
+var EMPTY_OBJECT = {};
+var BORDER_HEIGHT = 1;
+var HEADER = 'header';
+var FOOTER = 'footer';
+var CELL = 'cell';
+
+/**
+ * Data grid component with fixed or scrollable header and columns.
+ *
+ * The layout of the data table is as follows:
+ *
+ * ```
+ * +---------------------------------------------------+
+ * | Fixed Column Group    | Scrollable Column Group   |
+ * | Header                | Header                    |
+ * |                       |                           |
+ * +---------------------------------------------------+
+ * |                       |                           |
+ * | Fixed Header Columns  | Scrollable Header Columns |
+ * |                       |                           |
+ * +-----------------------+---------------------------+
+ * |                       |                           |
+ * | Fixed Body Columns    | Scrollable Body Columns   |
+ * |                       |                           |
+ * +-----------------------+---------------------------+
+ * |                       |                           |
+ * | Fixed Footer Columns  | Scrollable Footer Columns |
+ * |                       |                           |
+ * +-----------------------+---------------------------+
+ * ```
+ *
+ * - Fixed Column Group Header: These are the headers for a group
+ *   of columns if included in the table that do not scroll
+ *   vertically or horizontally.
+ *
+ * - Scrollable Column Group Header: The header for a group of columns
+ *   that do not move while scrolling vertically, but move horizontally
+ *   with the horizontal scrolling.
+ *
+ * - Fixed Header Columns: The header columns that do not move while scrolling
+ *   vertically or horizontally.
+ *
+ * - Scrollable Header Columns: The header columns that do not move
+ *   while scrolling vertically, but move horizontally with the horizontal
+ *   scrolling.
+ *
+ * - Fixed Body Columns: The body columns that do not move while scrolling
+ *   horizontally, but move vertically with the vertical scrolling.
+ *
+ * - Scrollable Body Columns: The body columns that move while scrolling
+ *   vertically or horizontally.
+ */
+var FixedDataTable = React.createClass({
+
+  propTypes: {
+
+    /**
+     * Pixel width of table. If all columns do not fit,
+     * a horizontal scrollbar will appear.
+     */
+    width: PropTypes.number.isRequired,
+
+    /**
+     * Pixel height of table. If all rows do not fit,
+     * a vertical scrollbar will appear.
+     *
+     * Either `height` or `maxHeight` must be specified.
+     */
+    height: PropTypes.number,
+
+    /**
+     * Maximum pixel height of table. If all rows do not fit,
+     * a vertical scrollbar will appear.
+     *
+     * Either `height` or `maxHeight` must be specified.
+     */
+    maxHeight: PropTypes.number,
+
+    /**
+     * Pixel height of table's owner, this is used in a managed scrolling
+     * situation when you want to slide the table up from below the fold
+     * without having to constantly update the height on every scroll tick.
+     * Instead, vary this property on scroll. By using `ownerHeight`, we
+     * over-render the table while making sure the footer and horizontal
+     * scrollbar of the table are visible when the current space for the table
+     * in view is smaller than the final, over-flowing height of table. It
+     * allows us to avoid resizing and reflowing table when it is moving in the
+     * view.
+     *
+     * This is used if `ownerHeight < height` (or `maxHeight`).
+     */
+    ownerHeight: PropTypes.number,
+
+    overflowX: PropTypes.oneOf(['hidden', 'auto']),
+    overflowY: PropTypes.oneOf(['hidden', 'auto']),
+
+    /**
+     * Number of rows in the table.
+     */
+    rowsCount: PropTypes.number.isRequired,
+
+    /**
+     * Pixel height of rows unless `rowHeightGetter` is specified and returns
+     * different value.
+     */
+    rowHeight: PropTypes.number.isRequired,
+
+    /**
+     * If specified, `rowHeightGetter(index)` is called for each row and the
+     * returned value overrides `rowHeight` for particular row.
+     */
+    rowHeightGetter: PropTypes.func,
+
+    /**
+     * To get any additional CSS classes that should be added to a row,
+     * `rowClassNameGetter(index)` is called.
+     */
+    rowClassNameGetter: PropTypes.func,
+
+    /**
+     * Pixel height of the column group header.
+     */
+    groupHeaderHeight: PropTypes.number,
+
+    /**
+     * Pixel height of header.
+     */
+    headerHeight: PropTypes.number.isRequired,
+
+    /**
+     * Pixel height of footer.
+     */
+    footerHeight: PropTypes.number,
+
+    /**
+     * Value of horizontal scroll.
+     */
+    scrollLeft: PropTypes.number,
+
+    /**
+     * Index of column to scroll to.
+     */
+    scrollToColumn: PropTypes.number,
+
+    /**
+     * Value of vertical scroll.
+     */
+    scrollTop: PropTypes.number,
+
+    /**
+     * Index of row to scroll to.
+     */
+    scrollToRow: PropTypes.number,
+
+    /**
+     * Callback that is called when scrolling starts with current horizontal
+     * and vertical scroll values.
+     */
+    onScrollStart: PropTypes.func,
+
+    /**
+     * Callback that is called when scrolling ends or stops with new horizontal
+     * and vertical scroll values.
+     */
+    onScrollEnd: PropTypes.func,
+
+    /**
+     * Callback that is called when `rowHeightGetter` returns a different height
+     * for a row than the `rowHeight` prop. This is necessary because initially
+     * table estimates heights of some parts of the content.
+     */
+    onContentHeightChange: PropTypes.func,
+
+    /**
+     * Callback that is called when a row is clicked.
+     */
+    onRowClick: PropTypes.func,
+
+    /**
+     * Callback that is called when a row is double clicked.
+     */
+    onRowDoubleClick: PropTypes.func,
+
+    /**
+     * Callback that is called when a mouse-down event happens on a row.
+     */
+    onRowMouseDown: PropTypes.func,
+
+    /**
+     * Callback that is called when a mouse-enter event happens on a row.
+     */
+    onRowMouseEnter: PropTypes.func,
+
+    /**
+     * Callback that is called when a mouse-leave event happens on a row.
+     */
+    onRowMouseLeave: PropTypes.func,
+
+    /**
+     * Callback that is called when resizer has been released
+     * and column needs to be updated.
+     *
+     * Required if the isResizable property is true on any column.
+     *
+     * ```
+     * function(
+     *   newColumnWidth: number,
+     *   columnKey: string,
+     * )
+     * ```
+     */
+    onColumnResizeEndCallback: PropTypes.func,
+
+    /**
+     * Whether a column is currently being resized.
+     */
+    isColumnResizing: PropTypes.bool,
+  },
+
+  getDefaultProps() /*object*/ {
+    return {
+      footerHeight: 0,
+      groupHeaderHeight: 0,
+      headerHeight: 0,
+      scrollLeft: 0,
+      scrollTop: 0,
+    };
+  },
+
+  getInitialState() /*object*/ {
+    var props = this.props;
+    var viewportHeight =
+      (props.height === undefined ? props.maxHeight : props.height) -
+      (props.headerHeight || 0) -
+      (props.footerHeight || 0) -
+      (props.groupHeaderHeight || 0);
+    this._scrollHelper = new FixedDataTableScrollHelper(
+      props.rowsCount,
+      props.rowHeight,
+      viewportHeight,
+      props.rowHeightGetter
+    );
+    if (props.scrollTop) {
+      this._scrollHelper.scrollTo(props.scrollTop);
+    }
+    this._didScrollStop = debounceCore(this._didScrollStop, 200, this);
+
+    return this._calculateState(this.props);
+  },
+
+  componentWillMount() {
+    var scrollToRow = this.props.scrollToRow;
+    if (scrollToRow !== undefined && scrollToRow !== null) {
+      this._rowToScrollTo = scrollToRow;
+    }
+    var scrollToColumn = this.props.scrollToColumn;
+    if (scrollToColumn !== undefined && scrollToColumn !== null) {
+      this._columnToScrollTo = scrollToColumn;
+    }
+    this._wheelHandler = new ReactWheelHandler(
+      this._onWheel,
+      this._shouldHandleWheelX,
+      this._shouldHandleWheelY
+    );
+  },
+
+  _shouldHandleWheelX(/*number*/ delta) /*boolean*/ {
+    if (this.props.overflowX === 'hidden') {
+      return false;
+    }
+
+    delta = Math.round(delta);
+    if (delta === 0) {
+      return false;
+    }
+
+    return (
+      (delta < 0 && this.state.scrollX > 0) ||
+      (delta >= 0 && this.state.scrollX < this.state.maxScrollX)
+    );
+  },
+
+  _shouldHandleWheelY(/*number*/ delta) /*boolean*/ {
+    if (this.props.overflowY === 'hidden'|| delta === 0) {
+      return false;
+    }
+
+    delta = Math.round(delta);
+    if (delta === 0) {
+      return false;
+    }
+
+    return (
+      (delta < 0 && this.state.scrollY > 0) ||
+      (delta >= 0 && this.state.scrollY < this.state.maxScrollY)
+    );
+  },
+
+  _reportContentHeight() {
+    var scrollContentHeight = this.state.scrollContentHeight;
+    var reservedHeight = this.state.reservedHeight;
+    var requiredHeight = scrollContentHeight + reservedHeight;
+    var contentHeight;
+    var useMaxHeight = this.props.height === undefined;
+    if (useMaxHeight && this.props.maxHeight > requiredHeight) {
+      contentHeight = requiredHeight;
+    } else if (this.state.height > requiredHeight && this.props.ownerHeight) {
+      contentHeight = Math.max(requiredHeight, this.props.ownerHeight);
+    } else {
+      contentHeight = this.state.height + this.state.maxScrollY;
+    }
+    if (contentHeight !== this._contentHeight &&
+        this.props.onContentHeightChange) {
+      this.props.onContentHeightChange(contentHeight);
+    }
+    this._contentHeight = contentHeight;
+  },
+
+  componentDidMount() {
+    this._reportContentHeight();
+  },
+
+  componentWillReceiveProps(/*object*/ nextProps) {
+    var scrollToRow = nextProps.scrollToRow;
+    if (scrollToRow !== undefined && scrollToRow !== null) {
+      this._rowToScrollTo = scrollToRow;
+    }
+    var scrollToColumn = nextProps.scrollToColumn;
+    if (scrollToColumn !== undefined && scrollToColumn !== null) {
+      this._columnToScrollTo = scrollToColumn;
+    }
+
+    var newOverflowX = nextProps.overflowX;
+    var newOverflowY = nextProps.overflowY;
+    if (newOverflowX !== this.props.overflowX ||
+        newOverflowY !== this.props.overflowY) {
+      this._wheelHandler = new ReactWheelHandler(
+        this._onWheel,
+        newOverflowX !== 'hidden', // Should handle horizontal scroll
+        newOverflowY !== 'hidden' // Should handle vertical scroll
+      );
+    }
+
+    // In the case of controlled scrolling, notify.
+    if (this.props.ownerHeight !== nextProps.ownerHeight ||
+      this.props.scrollTop !== nextProps.scrollTop) {
+      this._didScrollStart();
+    }
+    this._didScrollStop();
+
+    this.setState(this._calculateState(nextProps, this.state));
+  },
+
+  componentDidUpdate() {
+    this._reportContentHeight();
+  },
+
+  render() /*object*/ {
+    var state = this.state;
+    var props = this.props;
+
+    var groupHeader;
+    if (state.useGroupHeader) {
+      groupHeader = (
+        <FixedDataTableRow
+          key="group_header"
+          isScrolling={this._isScrolling}
+          className={joinClasses(
+            cx('fixedDataTableLayout/header'),
+            cx('public/fixedDataTable/header'),
+          )}
+          width={state.width}
+          height={state.groupHeaderHeight}
+          index={0}
+          zIndex={1}
+          offsetTop={0}
+          scrollLeft={state.scrollX}
+          fixedColumns={state.groupHeaderFixedColumns}
+          scrollableColumns={state.groupHeaderScrollableColumns}
+          onColumnResize={this._onColumnResize}
+        />
+      );
+    }
+
+    var maxScrollY = this.state.maxScrollY;
+    var showScrollbarX = state.maxScrollX > 0 && state.overflowX !== 'hidden';
+    var showScrollbarY = maxScrollY > 0 && state.overflowY !== 'hidden';
+    var scrollbarXHeight = showScrollbarX ? Scrollbar.SIZE : 0;
+    var scrollbarYHeight = state.height - scrollbarXHeight -
+        (2 * BORDER_HEIGHT) - state.footerHeight;
+
+    var headerOffsetTop = state.useGroupHeader ? state.groupHeaderHeight : 0;
+    var bodyOffsetTop = headerOffsetTop + state.headerHeight;
+    scrollbarYHeight -= bodyOffsetTop;
+    var bottomSectionOffset = 0;
+    var footOffsetTop = props.maxHeight != null
+      ? bodyOffsetTop + state.bodyHeight
+      : bodyOffsetTop + scrollbarYHeight;
+    var rowsContainerHeight = footOffsetTop + state.footerHeight;
+
+    if (props.ownerHeight !== undefined && props.ownerHeight < state.height) {
+      bottomSectionOffset = props.ownerHeight - state.height;
+
+      footOffsetTop = Math.min(
+        footOffsetTop,
+        props.ownerHeight - state.footerHeight - scrollbarXHeight
+      );
+
+      scrollbarYHeight = Math.max(0, footOffsetTop - bodyOffsetTop);
+    }
+
+    var verticalScrollbar;
+    if (showScrollbarY) {
+      verticalScrollbar =
+        <Scrollbar
+          size={scrollbarYHeight}
+          contentSize={scrollbarYHeight + maxScrollY}
+          onScroll={this._onVerticalScroll}
+          verticalTop={bodyOffsetTop}
+          position={state.scrollY}
+        />;
+    }
+
+    var horizontalScrollbar;
+    if (showScrollbarX) {
+      var scrollbarXWidth = state.width;
+      horizontalScrollbar =
+        <HorizontalScrollbar
+          contentSize={scrollbarXWidth + state.maxScrollX}
+          offset={bottomSectionOffset}
+          onScroll={this._onHorizontalScroll}
+          position={state.scrollX}
+          size={scrollbarXWidth}
+        />;
+    }
+
+    var dragKnob =
+      <FixedDataTableColumnResizeHandle
+        height={state.height}
+        initialWidth={state.columnResizingData.width || 0}
+        minWidth={state.columnResizingData.minWidth || 0}
+        maxWidth={state.columnResizingData.maxWidth || Number.MAX_VALUE}
+        visible={!!state.isColumnResizing}
+        leftOffset={state.columnResizingData.left || 0}
+        knobHeight={state.headerHeight}
+        initialEvent={state.columnResizingData.initialEvent}
+        onColumnResizeEnd={props.onColumnResizeEndCallback}
+        columnKey={state.columnResizingData.key}
+      />;
+
+    var footer = null;
+    if (state.footerHeight) {
+      footer =
+        <FixedDataTableRow
+          key="footer"
+          isScrolling={this._isScrolling}
+          className={joinClasses(
+            cx('fixedDataTableLayout/footer'),
+            cx('public/fixedDataTable/footer'),
+          )}
+          width={state.width}
+          height={state.footerHeight}
+          index={-1}
+          zIndex={1}
+          offsetTop={footOffsetTop}
+          fixedColumns={state.footFixedColumns}
+          scrollableColumns={state.footScrollableColumns}
+          scrollLeft={state.scrollX}
+        />;
+    }
+
+    var rows = this._renderRows(bodyOffsetTop);
+
+    var header =
+      <FixedDataTableRow
+        key="header"
+        isScrolling={this._isScrolling}
+        className={joinClasses(
+          cx('fixedDataTableLayout/header'),
+          cx('public/fixedDataTable/header'),
+        )}
+        width={state.width}
+        height={state.headerHeight}
+        index={-1}
+        zIndex={1}
+        offsetTop={headerOffsetTop}
+        scrollLeft={state.scrollX}
+        fixedColumns={state.headFixedColumns}
+        scrollableColumns={state.headScrollableColumns}
+        onColumnResize={this._onColumnResize}
+      />;
+
+    var topShadow;
+    var bottomShadow;
+    if (state.scrollY) {
+      topShadow =
+        <div
+          className={joinClasses(
+            cx('fixedDataTableLayout/topShadow'),
+            cx('public/fixedDataTable/topShadow'),
+          )}
+          style={{top: bodyOffsetTop}}
+        />;
+    }
+
+    if (
+      (state.ownerHeight != null &&
+        state.ownerHeight < state.height &&
+        state.scrollContentHeight + state.reservedHeight > state.ownerHeight) ||
+      state.scrollY < maxScrollY
+    ) {
+      bottomShadow =
+        <div
+          className={joinClasses(
+            cx('fixedDataTableLayout/bottomShadow'),
+            cx('public/fixedDataTable/bottomShadow'),
+          )}
+          style={{top: footOffsetTop}}
+        />;
+    }
+
+    return (
+      <div
+        className={joinClasses(
+          cx('fixedDataTableLayout/main'),
+          cx('public/fixedDataTable/main'),
+        )}
+        onWheel={this._wheelHandler.onWheel}
+        style={{height: state.height, width: state.width}}>
+        <div
+          className={cx('fixedDataTableLayout/rowsContainer')}
+          style={{height: rowsContainerHeight, width: state.width}}>
+          {dragKnob}
+          {groupHeader}
+          {header}
+          {rows}
+          {footer}
+          {topShadow}
+          {bottomShadow}
+        </div>
+        {verticalScrollbar}
+        {horizontalScrollbar}
+      </div>
+    );
+  },
+
+  _renderRows(/*number*/ offsetTop) /*object*/ {
+    var state = this.state;
+
+    return (
+      <FixedDataTableBufferedRows
+        isScrolling={this._isScrolling}
+        defaultRowHeight={state.rowHeight}
+        firstRowIndex={state.firstRowIndex}
+        firstRowOffset={state.firstRowOffset}
+        fixedColumns={state.bodyFixedColumns}
+        height={state.bodyHeight}
+        offsetTop={offsetTop}
+        onRowClick={state.onRowClick}
+        onRowDoubleClick={state.onRowDoubleClick}
+        onRowMouseDown={state.onRowMouseDown}
+        onRowMouseEnter={state.onRowMouseEnter}
+        onRowMouseLeave={state.onRowMouseLeave}
+        rowClassNameGetter={state.rowClassNameGetter}
+        rowsCount={state.rowsCount}
+        rowGetter={state.rowGetter}
+        rowHeightGetter={state.rowHeightGetter}
+        scrollLeft={state.scrollX}
+        scrollableColumns={state.bodyScrollableColumns}
+        showLastRowBorder={true}
+        width={state.width}
+        rowPositionGetter={this._scrollHelper.getRowPosition}
+      />
+    );
+  },
+
+  /**
+   * This is called when a cell that is in the header of a column has its
+   * resizer knob clicked on. It displays the resizer and puts in the correct
+   * location on the table.
+   */
+  _onColumnResize(
+    /*number*/ combinedWidth,
+    /*number*/ leftOffset,
+    /*number*/ cellWidth,
+    /*?number*/ cellMinWidth,
+    /*?number*/ cellMaxWidth,
+    /*number|string*/ columnKey,
+    /*object*/ event
+  ) {
+    this.setState({
+      isColumnResizing: true,
+      columnResizingData: {
+        left: leftOffset + combinedWidth - cellWidth,
+        width: cellWidth,
+        minWidth: cellMinWidth,
+        maxWidth: cellMaxWidth,
+        initialEvent: {
+          clientX: event.clientX,
+          clientY: event.clientY,
+          preventDefault: emptyFunction
+        },
+        key: columnKey
+      }
+    });
+  },
+
+  _areColumnSettingsIdentical(
+    oldColumns: Array,
+    newColumns: Array
+  ): boolean {
+    if (oldColumns.length !== newColumns.length) {
+      return false;
+    }
+    for (var index = 0; index < oldColumns.length; ++index) {
+      if (!shallowEqual(
+          oldColumns[index].props,
+          newColumns[index].props
+      )) {
+        return false;
+      }
+    }
+    return true;
+  },
+
+  _populateColumnsAndColumnData(
+    columns: Array,
+    columnGroups: ?Array,
+    oldState: ?Object
+  ): Object {
+    var canReuseColumnSettings = false;
+    var canReuseColumnGroupSettings = false;
+
+    if (oldState && oldState.columns) {
+      canReuseColumnSettings =
+        this._areColumnSettingsIdentical(columns, oldState.columns);
+    }
+    if (oldState && oldState.columnGroups && columnGroups) {
+      canReuseColumnGroupSettings =
+        this._areColumnSettingsIdentical(columnGroups, oldState.columnGroups);
+    }
+
+    var columnInfo = {};
+    if (canReuseColumnSettings) {
+      columnInfo.bodyFixedColumns = oldState.bodyFixedColumns;
+      columnInfo.bodyScrollableColumns = oldState.bodyScrollableColumns;
+      columnInfo.headFixedColumns = oldState.headFixedColumns;
+      columnInfo.headScrollableColumns = oldState.headScrollableColumns;
+      columnInfo.footFixedColumns = oldState.footFixedColumns;
+      columnInfo.footScrollableColumns = oldState.footScrollableColumns;
+    } else {
+      var bodyColumnTypes = this._splitColumnTypes(columns);
+      columnInfo.bodyFixedColumns = bodyColumnTypes.fixed;
+      columnInfo.bodyScrollableColumns = bodyColumnTypes.scrollable;
+
+      var headColumnTypes = this._splitColumnTypes(
+        this._selectColumnElement(HEADER, columns)
+      );
+      columnInfo.headFixedColumns = headColumnTypes.fixed;
+      columnInfo.headScrollableColumns = headColumnTypes.scrollable;
+
+      var footColumnTypes = this._splitColumnTypes(
+        this._selectColumnElement(FOOTER, columns)
+      );
+      columnInfo.footFixedColumns = footColumnTypes.fixed;
+      columnInfo.footScrollableColumns = footColumnTypes.scrollable;
+    }
+
+    if (canReuseColumnGroupSettings) {
+      columnInfo.groupHeaderFixedColumns = oldState.groupHeaderFixedColumns;
+      columnInfo.groupHeaderScrollableColumns =
+        oldState.groupHeaderScrollableColumns;
+    } else {
+      if (columnGroups) {
+        var groupHeaderColumnTypes = this._splitColumnTypes(
+          this._selectColumnElement(HEADER, columnGroups)
+        );
+        columnInfo.groupHeaderFixedColumns = groupHeaderColumnTypes.fixed;
+        columnInfo.groupHeaderScrollableColumns =
+          groupHeaderColumnTypes.scrollable;
+      }
+    }
+
+    return columnInfo;
+  },
+
+  _calculateState(/*object*/ props, /*?object*/ oldState) /*object*/ {
+    invariant(
+      props.height !== undefined || props.maxHeight !== undefined,
+      'You must set either a height or a maxHeight'
+    );
+
+    var children = [];
+    ReactChildren.forEach(props.children, (child, index) => {
+      if (child == null) {
+        return;
+      }
+      invariant(
+        child.type.__TableColumnGroup__ ||
+        child.type.__TableColumn__,
+        'child type should be <FixedDataTableColumn /> or ' +
+        '<FixedDataTableColumnGroup />'
+      );
+      children.push(child);
+    });
+
+    var useGroupHeader = false;
+    if (children.length && children[0].type.__TableColumnGroup__) {
+      useGroupHeader = true;
+    }
+
+    var firstRowIndex = (oldState && oldState.firstRowIndex) || 0;
+    var firstRowOffset = (oldState && oldState.firstRowOffset) || 0;
+    var scrollX, scrollY;
+    if (oldState && props.overflowX !== 'hidden') {
+      scrollX = oldState.scrollX;
+    } else {
+      scrollX = props.scrollLeft;
+    }
+    if (oldState && props.overflowY !== 'hidden') {
+      scrollY = oldState.scrollY;
+    } else {
+      scrollState = this._scrollHelper.scrollTo(props.scrollTop);
+      firstRowIndex = scrollState.index;
+      firstRowOffset = scrollState.offset;
+      scrollY = scrollState.position;
+    }
+
+    if (this._rowToScrollTo !== undefined) {
+      scrollState =
+        this._scrollHelper.scrollRowIntoView(this._rowToScrollTo);
+      firstRowIndex = scrollState.index;
+      firstRowOffset = scrollState.offset;
+      scrollY = scrollState.position;
+      delete this._rowToScrollTo;
+    }
+
+    var groupHeaderHeight = useGroupHeader ? props.groupHeaderHeight : 0;
+
+    if (oldState && props.rowsCount !== oldState.rowsCount) {
+      // Number of rows changed, try to scroll to the row from before the
+      // change
+      var viewportHeight =
+        (props.height === undefined ? props.maxHeight : props.height) -
+        (props.headerHeight || 0) -
+        (props.footerHeight || 0) -
+        (props.groupHeaderHeight || 0);
+      this._scrollHelper = new FixedDataTableScrollHelper(
+        props.rowsCount,
+        props.rowHeight,
+        viewportHeight,
+        props.rowHeightGetter
+      );
+      var scrollState =
+        this._scrollHelper.scrollToRow(firstRowIndex, firstRowOffset);
+      firstRowIndex = scrollState.index;
+      firstRowOffset = scrollState.offset;
+      scrollY = scrollState.position;
+    } else if (oldState && props.rowHeightGetter !== oldState.rowHeightGetter) {
+      this._scrollHelper.setRowHeightGetter(props.rowHeightGetter);
+    }
+
+    var columnResizingData;
+    if (props.isColumnResizing) {
+      columnResizingData = oldState && oldState.columnResizingData;
+    } else {
+      columnResizingData = EMPTY_OBJECT;
+    }
+
+    var columns;
+    var columnGroups;
+
+    if (useGroupHeader) {
+      var columnGroupSettings =
+        FixedDataTableWidthHelper.adjustColumnGroupWidths(
+          children,
+          props.width
+      );
+      columns = columnGroupSettings.columns;
+      columnGroups = columnGroupSettings.columnGroups;
+    } else {
+      columns = FixedDataTableWidthHelper.adjustColumnWidths(
+        children,
+        props.width
+      );
+    }
+
+    var columnInfo = this._populateColumnsAndColumnData(
+      columns,
+      columnGroups,
+      oldState
+    );
+
+    if (this._columnToScrollTo !== undefined) {
+      // If selected column is a fixed column, don't scroll
+      var fixedColumnsCount = columnInfo.bodyFixedColumns.length;
+      if (this._columnToScrollTo >= fixedColumnsCount) {
+        var totalFixedColumnsWidth = 0;
+        var i, column;
+        for (i = 0; i < columnInfo.bodyFixedColumns.length; ++i) {
+          column = columnInfo.bodyFixedColumns[i];
+          totalFixedColumnsWidth += column.props.width;
+        }
+
+        var scrollableColumnIndex = Math.min(
+          this._columnToScrollTo - fixedColumnsCount,
+          columnInfo.bodyScrollableColumns.length - 1,
+        );
+
+        var previousColumnsWidth = 0;
+        for (i = 0; i < scrollableColumnIndex; ++i) {
+          column = columnInfo.bodyScrollableColumns[i];
+          previousColumnsWidth += column.props.width;
+        }
+
+        var availableScrollWidth = props.width - totalFixedColumnsWidth;
+        var selectedColumnWidth = columnInfo.bodyScrollableColumns[
+          scrollableColumnIndex
+        ].props.width;
+        var minAcceptableScrollPosition =
+          previousColumnsWidth + selectedColumnWidth - availableScrollWidth;
+
+        if (scrollX < minAcceptableScrollPosition) {
+          scrollX = minAcceptableScrollPosition;
+        }
+
+        if (scrollX > previousColumnsWidth) {
+          scrollX = previousColumnsWidth;
+        }
+      }
+      delete this._columnToScrollTo;
+    }
+
+    var useMaxHeight = props.height === undefined;
+    var height = Math.round(useMaxHeight ? props.maxHeight : props.height);
+    var totalHeightReserved = props.footerHeight + props.headerHeight +
+      groupHeaderHeight + 2 * BORDER_HEIGHT;
+    var bodyHeight = height - totalHeightReserved;
+    var scrollContentHeight = this._scrollHelper.getContentHeight();
+    var totalHeightNeeded = scrollContentHeight + totalHeightReserved;
+    var scrollContentWidth =
+      FixedDataTableWidthHelper.getTotalWidth(columns);
+
+    var horizontalScrollbarVisible = scrollContentWidth > props.width &&
+      props.overflowX !== 'hidden';
+
+    if (horizontalScrollbarVisible) {
+      bodyHeight -= Scrollbar.SIZE;
+      totalHeightNeeded += Scrollbar.SIZE;
+      totalHeightReserved += Scrollbar.SIZE;
+    }
+
+    var maxScrollX = Math.max(0, scrollContentWidth - props.width);
+    var maxScrollY = Math.max(0, scrollContentHeight - bodyHeight);
+    scrollX = Math.min(scrollX, maxScrollX);
+    scrollY = Math.min(scrollY, maxScrollY);
+
+    if (!maxScrollY) {
+      // no vertical scrollbar necessary, use the totals we tracked so we
+      // can shrink-to-fit vertically
+      if (useMaxHeight) {
+        height = totalHeightNeeded;
+      }
+      bodyHeight = totalHeightNeeded - totalHeightReserved;
+    }
+
+    this._scrollHelper.setViewportHeight(bodyHeight);
+
+    // The order of elements in this object metters and bringing bodyHeight,
+    // height or useGroupHeader to the top can break various features
+    var newState = {
+      isColumnResizing: oldState && oldState.isColumnResizing,
+      // isColumnResizing should be overwritten by value from props if
+      // avaialble
+
+      ...columnInfo,
+      ...props,
+
+      columns,
+      columnGroups,
+      columnResizingData,
+      firstRowIndex,
+      firstRowOffset,
+      horizontalScrollbarVisible,
+      maxScrollX,
+      maxScrollY,
+      reservedHeight: totalHeightReserved,
+      scrollContentHeight,
+      scrollX,
+      scrollY,
+
+      // These properties may overwrite properties defined in
+      // columnInfo and props
+      bodyHeight,
+      height,
+      groupHeaderHeight,
+      useGroupHeader,
+    };
+
+    return newState;
+  },
+
+  _selectColumnElement(/*string*/ type, /*array*/ columns) /*array*/ {
+    var newColumns = [];
+    for (var i = 0; i < columns.length; ++i) {
+      var column = columns[i];
+      newColumns.push(React.cloneElement(
+        column,
+        {
+          cell: type ?  column.props[type] : column.props[CELL]
+        }
+      ));
+    }
+    return newColumns;
+  },
+
+  _splitColumnTypes(/*array*/ columns) /*object*/ {
+    var fixedColumns = [];
+    var scrollableColumns = [];
+    for (var i = 0; i < columns.length; ++i) {
+      if (columns[i].props.fixed) {
+        fixedColumns.push(columns[i]);
+      } else {
+        scrollableColumns.push(columns[i]);
+      }
+    }
+    return {
+      fixed: fixedColumns,
+      scrollable: scrollableColumns,
+    };
+  },
+
+  _onWheel(/*number*/ deltaX, /*number*/ deltaY) {
+    if (this.isMounted()) {
+      if (!this._isScrolling) {
+        this._didScrollStart();
+      }
+      var x = this.state.scrollX;
+      if (Math.abs(deltaY) > Math.abs(deltaX) &&
+          this.props.overflowY !== 'hidden') {
+        var scrollState = this._scrollHelper.scrollBy(Math.round(deltaY));
+        var maxScrollY = Math.max(
+          0,
+          scrollState.contentHeight - this.state.bodyHeight
+        );
+        this.setState({
+          firstRowIndex: scrollState.index,
+          firstRowOffset: scrollState.offset,
+          scrollY: scrollState.position,
+          scrollContentHeight: scrollState.contentHeight,
+          maxScrollY: maxScrollY,
+        });
+      } else if (deltaX && this.props.overflowX !== 'hidden') {
+        x += deltaX;
+        x = x < 0 ? 0 : x;
+        x = x > this.state.maxScrollX ? this.state.maxScrollX : x;
+        this.setState({
+          scrollX: x,
+        });
+      }
+
+      this._didScrollStop();
+    }
+  },
+
+
+  _onHorizontalScroll(/*number*/ scrollPos) {
+    if (this.isMounted() && scrollPos !== this.state.scrollX) {
+      if (!this._isScrolling) {
+        this._didScrollStart();
+      }
+      this.setState({
+        scrollX: scrollPos,
+      });
+      this._didScrollStop();
+    }
+  },
+
+  _onVerticalScroll(/*number*/ scrollPos) {
+    if (this.isMounted() && scrollPos !== this.state.scrollY) {
+      if (!this._isScrolling) {
+        this._didScrollStart();
+      }
+      var scrollState = this._scrollHelper.scrollTo(Math.round(scrollPos));
+      this.setState({
+        firstRowIndex: scrollState.index,
+        firstRowOffset: scrollState.offset,
+        scrollY: scrollState.position,
+        scrollContentHeight: scrollState.contentHeight,
+      });
+      this._didScrollStop();
+    }
+  },
+
+  _didScrollStart() {
+    if (this.isMounted() && !this._isScrolling) {
+      this._isScrolling = true;
+      if (this.props.onScrollStart) {
+        this.props.onScrollStart(this.state.scrollX, this.state.scrollY);
+      }
+    }
+  },
+
+  _didScrollStop() {
+    if (this.isMounted() && this._isScrolling) {
+      this._isScrolling = false;
+      this.setState({redraw: true});
+      if (this.props.onScrollEnd) {
+        this.props.onScrollEnd(this.state.scrollX, this.state.scrollY);
+      }
+    }
+  },
+});
+
+var HorizontalScrollbar = React.createClass({
+  mixins: [ReactComponentWithPureRenderMixin],
+  propTypes: {
+    contentSize: PropTypes.number.isRequired,
+    offset: PropTypes.number.isRequired,
+    onScroll: PropTypes.func.isRequired,
+    position: PropTypes.number.isRequired,
+    size: PropTypes.number.isRequired,
+  },
+
+  render() /*object*/ {
+    var outerContainerStyle = {
+      height: Scrollbar.SIZE,
+      width: this.props.size,
+    };
+    var innerContainerStyle = {
+      height: Scrollbar.SIZE,
+      position: 'absolute',
+      overflow: 'hidden',
+      width: this.props.size,
+    };
+    translateDOMPositionXY(
+      innerContainerStyle,
+      0,
+      this.props.offset
+    );
+
+    return (
+      <div
+        className={joinClasses(
+          cx('fixedDataTableLayout/horizontalScrollbar'),
+          cx('public/fixedDataTable/horizontalScrollbar'),
+        )}
+        style={outerContainerStyle}>
+        <div style={innerContainerStyle}>
+          <Scrollbar
+            {...this.props}
+            isOpaque={true}
+            orientation="horizontal"
+            offset={undefined}
+          />
+        </div>
+      </div>
+    );
+  },
+});
+
+module.exports = FixedDataTable;
diff --git a/src/FixedDataTableColumn.react.js b/src/FixedDataTableColumn.react.js
new file mode 100644
index 0000000..2ed6f5d
--- /dev/null
+++ b/src/FixedDataTableColumn.react.js
@@ -0,0 +1,189 @@
+/**
+ * Copyright (c) 2015, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ * @providesModule FixedDataTableColumn.react
+ * @typechecks
+ */
+
+var React = require('React');
+
+var {PropTypes} = React;
+
+/**
+ * Component that defines the attributes of table column.
+ */
+var FixedDataTableColumn = React.createClass({
+  statics: {
+    __TableColumn__: true
+  },
+
+  propTypes: {
+    /**
+     * The horizontal alignment of the table cell content.
+     */
+    align: PropTypes.oneOf(['left', 'center', 'right']),
+
+    /**
+     * Controls if the column is fixed when scrolling in the X axis.
+     */
+    fixed: PropTypes.bool,
+
+    /**
+     * The header cell for this column.
+     * This can either be a string a React element, or a function that generates
+     * a React Element. Passing in a string will render a default header cell
+     * with that string. By default, the React element passed in can expect to
+     * receive the following props:
+     *
+     * ```
+     * props: {
+     *   columnKey: string // (of the column, if given)
+     *   height: number // (supplied from the Table or rowHeightGetter)
+     *   width: number // (supplied from the Column)
+     * }
+     * ```
+     *
+     * Because you are passing in your own React element, you can feel free to
+     * pass in whatever props you may want or need.
+     *
+     * If you pass in a function, you will receive the same props object as the
+     * first argument.
+     */
+    header: PropTypes.oneOfType([
+      PropTypes.node,
+      PropTypes.func,
+    ]),
+
+    /**
+     * This is the body cell that will be cloned for this column.
+     * This can either be a string a React element, or a function that generates
+     * a React Element. Passing in a string will render a default header cell
+     * with that string. By default, the React element passed in can expect to
+     * receive the following props:
+     *
+     * ```
+     * props: {
+     *   rowIndex; number // (the row index of the cell)
+     *   columnKey: string // (of the column, if given)
+     *   height: number // (supplied from the Table or rowHeightGetter)
+     *   width: number // (supplied from the Column)
+     * }
+     * ```
+     *
+     * Because you are passing in your own React element, you can feel free to
+     * pass in whatever props you may want or need.
+     *
+     * If you pass in a function, you will receive the same props object as the
+     * first argument.
+     */
+    cell: PropTypes.oneOfType([
+      PropTypes.node,
+      PropTypes.func,
+    ]),
+
+    /**
+     * This is the footer cell for this column.
+     * This can either be a string a React element, or a function that generates
+     * a React Element. Passing in a string will render a default header cell
+     * with that string. By default, the React element passed in can expect to
+     * receive the following props:
+     *
+     * ```
+     * props: {
+     *   columnKey: string // (of the column, if given)
+     *   height: number // (supplied from the Table or rowHeightGetter)
+     *   width: number // (supplied from the Column)
+     * }
+     * ```
+     *
+     * Because you are passing in your own React element, you can feel free to
+     * pass in whatever props you may want or need.
+     *
+     * If you pass in a function, you will receive the same props object as the
+     * first argument.
+     */
+    footer: PropTypes.oneOfType([
+      PropTypes.node,
+      PropTypes.func,
+    ]),
+
+    /**
+     * This is used to uniquely identify the column, and is not required unless
+     * you a resizing columns. This will be the key given in the
+     * `onColumnResizeEndCallback` on the Table.
+     */
+    columnKey: PropTypes.oneOfType([
+      PropTypes.string,
+      PropTypes.number,
+    ]),
+
+    /**
+     * The pixel width of the column.
+     */
+    width: PropTypes.number.isRequired,
+
+    /**
+     * If this is a resizable column this is its minimum pixel width.
+     */
+    minWidth: PropTypes.number,
+
+    /**
+     * If this is a resizable column this is its maximum pixel width.
+     */
+    maxWidth: PropTypes.number,
+
+    /**
+     * The grow factor relative to other columns. Same as the flex-grow API
+     * from http://www.w3.org/TR/css3-flexbox/. Basically, take any available
+     * extra width and distribute it proportionally according to all columns'
+     * flexGrow values. Defaults to zero (no-flexing).
+     */
+    flexGrow: PropTypes.number,
+
+    /**
+     * Whether the column can be resized with the
+     * FixedDataTableColumnResizeHandle. Please note that if a column
+     * has a flex grow, once you resize the column this will be set to 0.
+     *
+     * This property only provides the UI for the column resizing. If this
+     * is set to true, you will need to set the onColumnResizeEndCallback table
+     * property and render your columns appropriately.
+     */
+    isResizable: PropTypes.bool,
+
+    /**
+     * Whether cells in this column can be removed from document when outside
+     * of viewport as a result of horizontal scrolling.
+     * Setting this property to true allows the table to not render cells in
+     * particular column that are outside of viewport for visible rows. This
+     * allows to create table with many columns and not have vertical scrolling
+     * performance drop.
+     * Setting the property to false will keep previous behaviour and keep
+     * cell rendered if the row it belongs to is visible.
+     */
+    allowCellsRecycling: PropTypes.bool,
+  },
+
+  getDefaultProps() /*object*/ {
+    return {
+      allowCellsRecycling: false,
+      fixed: false,
+    };
+  },
+
+  render() {
+    if (__DEV__) {
+      throw new Error(
+        'Component <FixedDataTableColumn /> should never render'
+      );
+    }
+    return null;
+  },
+});
+
+module.exports = FixedDataTableColumn;
diff --git a/src/FixedDataTableColumnGroup.react.js b/src/FixedDataTableColumnGroup.react.js
new file mode 100644
index 0000000..f43865e
--- /dev/null
+++ b/src/FixedDataTableColumnGroup.react.js
@@ -0,0 +1,78 @@
+/**
+ * Copyright (c) 2015, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ * @providesModule FixedDataTableColumnGroup.react
+ * @typechecks
+ */
+
+var React = require('React');
+
+var {PropTypes} = React;
+
+/**
+ * Component that defines the attributes of a table column group.
+ */
+var FixedDataTableColumnGroup = React.createClass({
+  statics: {
+    __TableColumnGroup__: true,
+  },
+
+  propTypes: {
+    /**
+     * The horizontal alignment of the table cell content.
+     */
+    align: PropTypes.oneOf(['left', 'center', 'right']),
+
+    /**
+     * Controls if the column group is fixed when scrolling in the X axis.
+     */
+    fixed: PropTypes.bool,
+
+    /**
+     * This is the header cell for this column group.
+     * This can either be a string or a React element. Passing in a string
+     * will render a default footer cell with that string. By default, the React
+     * element passed in can expect to receive the following props:
+     *
+     * ```
+     * props: {
+     *   height: number // (supplied from the groupHeaderHeight)
+     *   width: number // (supplied from the Column)
+     * }
+     * ```
+     *
+     * Because you are passing in your own React element, you can feel free to
+     * pass in whatever props you may want or need.
+     *
+     * You can also pass in a function that returns a react elemnt, with the
+     * props object above passed in as the first parameter.
+     */
+    header: PropTypes.oneOfType([
+      PropTypes.node,
+      PropTypes.func,
+    ]),
+
+  },
+
+  getDefaultProps() /*object*/ {
+    return {
+      fixed: false,
+    };
+  },
+
+  render() {
+    if (__DEV__) {
+      throw new Error(
+        'Component <FixedDataTableColumnGroup /> should never render'
+      );
+    }
+    return null;
+  },
+});
+
+module.exports = FixedDataTableColumnGroup;
diff --git a/src/FixedDataTableColumnGroupNew.react.js b/src/FixedDataTableColumnGroupNew.react.js
deleted file mode 100644
index 99dcb62..0000000
--- a/src/FixedDataTableColumnGroupNew.react.js
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * Copyright (c) 2015, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- *
- * @providesModule FixedDataTableColumnGroupNew.react
- * @typechecks
- */
-
-var React = require('React');
-
-var {PropTypes} = React;
-
-/**
- * Component that defines the attributes of a table column group.
- */
-var FixedDataTableColumnGroup = React.createClass({
-  statics: {
-    __TableColumnGroup__: true,
-  },
-
-  propTypes: {
-    /**
-     * The horizontal alignment of the table cell content.
-     */
-    align: PropTypes.oneOf(['left', 'center', 'right']),
-
-    /**
-     * Controls if the column group is fixed when scrolling in the X axis.
-     */
-    fixed: PropTypes.bool,
-
-    /**
-     * This is the header cell for this column group.
-     * This can either be a string or a React element. Passing in a string
-     * will render a default footer cell with that string. By default, the React
-     * element passed in can expect to receive the following props:
-     *
-     * ```
-     * props: {
-     *   height: number // (supplied from the groupHeaderHeight)
-     *   width: number // (supplied from the Column)
-     * }
-     * ```
-     *
-     * Because you are passing in your own React element, you can feel free to
-     * pass in whatever props you may want or need.
-     *
-     * You can also pass in a function that returns a react elemnt, with the
-     * props object above passed in as the first parameter.
-     */
-    header: PropTypes.oneOfType([
-      PropTypes.node,
-      PropTypes.func,
-    ]),
-
-  },
-
-  getDefaultProps() /*object*/ {
-    return {
-      fixed: false,
-    };
-  },
-
-  render() {
-    if (__DEV__) {
-      throw new Error(
-        'Component <FixedDataTableColumnGroup /> should never render'
-      );
-    }
-    return null;
-  },
-});
-
-module.exports = FixedDataTableColumnGroup;
diff --git a/src/FixedDataTableColumnNew.react.js b/src/FixedDataTableColumnNew.react.js
deleted file mode 100644
index 91b0571..0000000
--- a/src/FixedDataTableColumnNew.react.js
+++ /dev/null
@@ -1,189 +0,0 @@
-/**
- * Copyright (c) 2015, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- *
- * @providesModule FixedDataTableColumnNew.react
- * @typechecks
- */
-
-var React = require('React');
-
-var {PropTypes} = React;
-
-/**
- * Component that defines the attributes of table column.
- */
-var FixedDataTableColumn = React.createClass({
-  statics: {
-    __TableColumn__: true
-  },
-
-  propTypes: {
-    /**
-     * The horizontal alignment of the table cell content.
-     */
-    align: PropTypes.oneOf(['left', 'center', 'right']),
-
-    /**
-     * Controls if the column is fixed when scrolling in the X axis.
-     */
-    fixed: PropTypes.bool,
-
-    /**
-     * The header cell for this column.
-     * This can either be a string a React element, or a function that generates
-     * a React Element. Passing in a string will render a default header cell
-     * with that string. By default, the React element passed in can expect to
-     * receive the following props:
-     *
-     * ```
-     * props: {
-     *   columnKey: string // (of the column, if given)
-     *   height: number // (supplied from the Table or rowHeightGetter)
-     *   width: number // (supplied from the Column)
-     * }
-     * ```
-     *
-     * Because you are passing in your own React element, you can feel free to
-     * pass in whatever props you may want or need.
-     *
-     * If you pass in a function, you will receive the same props object as the
-     * first argument.
-     */
-    header: PropTypes.oneOfType([
-      PropTypes.node,
-      PropTypes.func,
-    ]),
-
-    /**
-     * This is the body cell that will be cloned for this column.
-     * This can either be a string a React element, or a function that generates
-     * a React Element. Passing in a string will render a default header cell
-     * with that string. By default, the React element passed in can expect to
-     * receive the following props:
-     *
-     * ```
-     * props: {
-     *   rowIndex; number // (the row index of the cell)
-     *   columnKey: string // (of the column, if given)
-     *   height: number // (supplied from the Table or rowHeightGetter)
-     *   width: number // (supplied from the Column)
-     * }
-     * ```
-     *
-     * Because you are passing in your own React element, you can feel free to
-     * pass in whatever props you may want or need.
-     *
-     * If you pass in a function, you will receive the same props object as the
-     * first argument.
-     */
-    cell: PropTypes.oneOfType([
-      PropTypes.node,
-      PropTypes.func,
-    ]),
-
-    /**
-     * This is the footer cell for this column.
-     * This can either be a string a React element, or a function that generates
-     * a React Element. Passing in a string will render a default header cell
-     * with that string. By default, the React element passed in can expect to
-     * receive the following props:
-     *
-     * ```
-     * props: {
-     *   columnKey: string // (of the column, if given)
-     *   height: number // (supplied from the Table or rowHeightGetter)
-     *   width: number // (supplied from the Column)
-     * }
-     * ```
-     *
-     * Because you are passing in your own React element, you can feel free to
-     * pass in whatever props you may want or need.
-     *
-     * If you pass in a function, you will receive the same props object as the
-     * first argument.
-     */
-    footer: PropTypes.oneOfType([
-      PropTypes.node,
-      PropTypes.func,
-    ]),
-
-    /**
-     * This is used to uniquely identify the column, and is not required unless
-     * you a resizing columns. This will be the key given in the
-     * `onColumnResizeEndCallback` on the Table.
-     */
-    columnKey: PropTypes.oneOfType([
-      PropTypes.string,
-      PropTypes.number,
-    ]),
-
-    /**
-     * The pixel width of the column.
-     */
-    width: PropTypes.number.isRequired,
-
-    /**
-     * If this is a resizable column this is its minimum pixel width.
-     */
-    minWidth: PropTypes.number,
-
-    /**
-     * If this is a resizable column this is its maximum pixel width.
-     */
-    maxWidth: PropTypes.number,
-
-    /**
-     * The grow factor relative to other columns. Same as the flex-grow API
-     * from http://www.w3.org/TR/css3-flexbox/. Basically, take any available
-     * extra width and distribute it proportionally according to all columns'
-     * flexGrow values. Defaults to zero (no-flexing).
-     */
-    flexGrow: PropTypes.number,
-
-    /**
-     * Whether the column can be resized with the
-     * FixedDataTableColumnResizeHandle. Please note that if a column
-     * has a flex grow, once you resize the column this will be set to 0.
-     *
-     * This property only provides the UI for the column resizing. If this
-     * is set to true, you will need to set the onColumnResizeEndCallback table
-     * property and render your columns appropriately.
-     */
-    isResizable: PropTypes.bool,
-
-    /**
-     * Whether cells in this column can be removed from document when outside
-     * of viewport as a result of horizontal scrolling.
-     * Setting this property to true allows the table to not render cells in
-     * particular column that are outside of viewport for visible rows. This
-     * allows to create table with many columns and not have vertical scrolling
-     * performance drop.
-     * Setting the property to false will keep previous behaviour and keep
-     * cell rendered if the row it belongs to is visible.
-     */
-    allowCellsRecycling: PropTypes.bool,
-  },
-
-  getDefaultProps() /*object*/ {
-    return {
-      allowCellsRecycling: false,
-      fixed: false,
-    };
-  },
-
-  render() {
-    if (__DEV__) {
-      throw new Error(
-        'Component <FixedDataTableColumn /> should never render'
-      );
-    }
-    return null;
-  },
-});
-
-module.exports = FixedDataTableColumn;
diff --git a/src/FixedDataTableNew.react.js b/src/FixedDataTableNew.react.js
deleted file mode 100644
index f9e2bd9..0000000
--- a/src/FixedDataTableNew.react.js
+++ /dev/null
@@ -1,1098 +0,0 @@
-/**
- * Copyright (c) 2015, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- *
- * @providesModule FixedDataTableNew.react
- * @typechecks
- * @noflow
- */
-
-/*eslint no-bitwise:1*/
-
-var React = require('React');
-var ReactComponentWithPureRenderMixin = require('ReactComponentWithPureRenderMixin');
-var ReactWheelHandler = require('ReactWheelHandler');
-var Scrollbar = require('Scrollbar.react');
-var FixedDataTableBufferedRows = require('FixedDataTableBufferedRows.react');
-var FixedDataTableColumnResizeHandle = require('FixedDataTableColumnResizeHandle.react');
-var FixedDataTableRow = require('FixedDataTableRow.react');
-var FixedDataTableScrollHelper = require('FixedDataTableScrollHelper');
-var FixedDataTableWidthHelper = require('FixedDataTableWidthHelper');
-
-var cx = require('cx');
-var debounceCore = require('debounceCore');
-var emptyFunction = require('emptyFunction');
-var invariant = require('invariant');
-var joinClasses = require('joinClasses');
-var shallowEqual = require('shallowEqual');
-var translateDOMPositionXY = require('translateDOMPositionXY');
-
-var {PropTypes} = React;
-var ReactChildren = React.Children;
-
-var EMPTY_OBJECT = {};
-var BORDER_HEIGHT = 1;
-var HEADER = 'header';
-var FOOTER = 'footer';
-var CELL = 'cell';
-
-/**
- * Data grid component with fixed or scrollable header and columns.
- *
- * The layout of the data table is as follows:
- *
- * ```
- * +---------------------------------------------------+
- * | Fixed Column Group    | Scrollable Column Group   |
- * | Header                | Header                    |
- * |                       |                           |
- * +---------------------------------------------------+
- * |                       |                           |
- * | Fixed Header Columns  | Scrollable Header Columns |
- * |                       |                           |
- * +-----------------------+---------------------------+
- * |                       |                           |
- * | Fixed Body Columns    | Scrollable Body Columns   |
- * |                       |                           |
- * +-----------------------+---------------------------+
- * |                       |                           |
- * | Fixed Footer Columns  | Scrollable Footer Columns |
- * |                       |                           |
- * +-----------------------+---------------------------+
- * ```
- *
- * - Fixed Column Group Header: These are the headers for a group
- *   of columns if included in the table that do not scroll
- *   vertically or horizontally.
- *
- * - Scrollable Column Group Header: The header for a group of columns
- *   that do not move while scrolling vertically, but move horizontally
- *   with the horizontal scrolling.
- *
- * - Fixed Header Columns: The header columns that do not move while scrolling
- *   vertically or horizontally.
- *
- * - Scrollable Header Columns: The header columns that do not move
- *   while scrolling vertically, but move horizontally with the horizontal
- *   scrolling.
- *
- * - Fixed Body Columns: The body columns that do not move while scrolling
- *   horizontally, but move vertically with the vertical scrolling.
- *
- * - Scrollable Body Columns: The body columns that move while scrolling
- *   vertically or horizontally.
- */
-var FixedDataTable = React.createClass({
-
-  propTypes: {
-
-    /**
-     * Pixel width of table. If all columns do not fit,
-     * a horizontal scrollbar will appear.
-     */
-    width: PropTypes.number.isRequired,
-
-    /**
-     * Pixel height of table. If all rows do not fit,
-     * a vertical scrollbar will appear.
-     *
-     * Either `height` or `maxHeight` must be specified.
-     */
-    height: PropTypes.number,
-
-    /**
-     * Maximum pixel height of table. If all rows do not fit,
-     * a vertical scrollbar will appear.
-     *
-     * Either `height` or `maxHeight` must be specified.
-     */
-    maxHeight: PropTypes.number,
-
-    /**
-     * Pixel height of table's owner, this is used in a managed scrolling
-     * situation when you want to slide the table up from below the fold
-     * without having to constantly update the height on every scroll tick.
-     * Instead, vary this property on scroll. By using `ownerHeight`, we
-     * over-render the table while making sure the footer and horizontal
-     * scrollbar of the table are visible when the current space for the table
-     * in view is smaller than the final, over-flowing height of table. It
-     * allows us to avoid resizing and reflowing table when it is moving in the
-     * view.
-     *
-     * This is used if `ownerHeight < height` (or `maxHeight`).
-     */
-    ownerHeight: PropTypes.number,
-
-    overflowX: PropTypes.oneOf(['hidden', 'auto']),
-    overflowY: PropTypes.oneOf(['hidden', 'auto']),
-
-    /**
-     * Number of rows in the table.
-     */
-    rowsCount: PropTypes.number.isRequired,
-
-    /**
-     * Pixel height of rows unless `rowHeightGetter` is specified and returns
-     * different value.
-     */
-    rowHeight: PropTypes.number.isRequired,
-
-    /**
-     * If specified, `rowHeightGetter(index)` is called for each row and the
-     * returned value overrides `rowHeight` for particular row.
-     */
-    rowHeightGetter: PropTypes.func,
-
-    /**
-     * To get any additional CSS classes that should be added to a row,
-     * `rowClassNameGetter(index)` is called.
-     */
-    rowClassNameGetter: PropTypes.func,
-
-    /**
-     * Pixel height of the column group header.
-     */
-    groupHeaderHeight: PropTypes.number,
-
-    /**
-     * Pixel height of header.
-     */
-    headerHeight: PropTypes.number.isRequired,
-
-    /**
-     * Pixel height of footer.
-     */
-    footerHeight: PropTypes.number,
-
-    /**
-     * Value of horizontal scroll.
-     */
-    scrollLeft: PropTypes.number,
-
-    /**
-     * Index of column to scroll to.
-     */
-    scrollToColumn: PropTypes.number,
-
-    /**
-     * Value of vertical scroll.
-     */
-    scrollTop: PropTypes.number,
-
-    /**
-     * Index of row to scroll to.
-     */
-    scrollToRow: PropTypes.number,
-
-    /**
-     * Callback that is called when scrolling starts with current horizontal
-     * and vertical scroll values.
-     */
-    onScrollStart: PropTypes.func,
-
-    /**
-     * Callback that is called when scrolling ends or stops with new horizontal
-     * and vertical scroll values.
-     */
-    onScrollEnd: PropTypes.func,
-
-    /**
-     * Callback that is called when `rowHeightGetter` returns a different height
-     * for a row than the `rowHeight` prop. This is necessary because initially
-     * table estimates heights of some parts of the content.
-     */
-    onContentHeightChange: PropTypes.func,
-
-    /**
-     * Callback that is called when a row is clicked.
-     */
-    onRowClick: PropTypes.func,
-
-    /**
-     * Callback that is called when a row is double clicked.
-     */
-    onRowDoubleClick: PropTypes.func,
-
-    /**
-     * Callback that is called when a mouse-down event happens on a row.
-     */
-    onRowMouseDown: PropTypes.func,
-
-    /**
-     * Callback that is called when a mouse-enter event happens on a row.
-     */
-    onRowMouseEnter: PropTypes.func,
-
-    /**
-     * Callback that is called when a mouse-leave event happens on a row.
-     */
-    onRowMouseLeave: PropTypes.func,
-
-    /**
-     * Callback that is called when resizer has been released
-     * and column needs to be updated.
-     *
-     * Required if the isResizable property is true on any column.
-     *
-     * ```
-     * function(
-     *   newColumnWidth: number,
-     *   columnKey: string,
-     * )
-     * ```
-     */
-    onColumnResizeEndCallback: PropTypes.func,
-
-    /**
-     * Whether a column is currently being resized.
-     */
-    isColumnResizing: PropTypes.bool,
-  },
-
-  getDefaultProps() /*object*/ {
-    return {
-      footerHeight: 0,
-      groupHeaderHeight: 0,
-      headerHeight: 0,
-      scrollLeft: 0,
-      scrollTop: 0,
-    };
-  },
-
-  getInitialState() /*object*/ {
-    var props = this.props;
-    var viewportHeight =
-      (props.height === undefined ? props.maxHeight : props.height) -
-      (props.headerHeight || 0) -
-      (props.footerHeight || 0) -
-      (props.groupHeaderHeight || 0);
-    this._scrollHelper = new FixedDataTableScrollHelper(
-      props.rowsCount,
-      props.rowHeight,
-      viewportHeight,
-      props.rowHeightGetter
-    );
-    if (props.scrollTop) {
-      this._scrollHelper.scrollTo(props.scrollTop);
-    }
-    this._didScrollStop = debounceCore(this._didScrollStop, 200, this);
-
-    return this._calculateState(this.props);
-  },
-
-  componentWillMount() {
-    var scrollToRow = this.props.scrollToRow;
-    if (scrollToRow !== undefined && scrollToRow !== null) {
-      this._rowToScrollTo = scrollToRow;
-    }
-    var scrollToColumn = this.props.scrollToColumn;
-    if (scrollToColumn !== undefined && scrollToColumn !== null) {
-      this._columnToScrollTo = scrollToColumn;
-    }
-    this._wheelHandler = new ReactWheelHandler(
-      this._onWheel,
-      this._shouldHandleWheelX,
-      this._shouldHandleWheelY
-    );
-  },
-
-  _shouldHandleWheelX(/*number*/ delta) /*boolean*/ {
-    if (this.props.overflowX === 'hidden') {
-      return false;
-    }
-
-    delta = Math.round(delta);
-    if (delta === 0) {
-      return false;
-    }
-
-    return (
-      (delta < 0 && this.state.scrollX > 0) ||
-      (delta >= 0 && this.state.scrollX < this.state.maxScrollX)
-    );
-  },
-
-  _shouldHandleWheelY(/*number*/ delta) /*boolean*/ {
-    if (this.props.overflowY === 'hidden'|| delta === 0) {
-      return false;
-    }
-
-    delta = Math.round(delta);
-    if (delta === 0) {
-      return false;
-    }
-
-    return (
-      (delta < 0 && this.state.scrollY > 0) ||
-      (delta >= 0 && this.state.scrollY < this.state.maxScrollY)
-    );
-  },
-
-  _reportContentHeight() {
-    var scrollContentHeight = this.state.scrollContentHeight;
-    var reservedHeight = this.state.reservedHeight;
-    var requiredHeight = scrollContentHeight + reservedHeight;
-    var contentHeight;
-    var useMaxHeight = this.props.height === undefined;
-    if (useMaxHeight && this.props.maxHeight > requiredHeight) {
-      contentHeight = requiredHeight;
-    } else if (this.state.height > requiredHeight && this.props.ownerHeight) {
-      contentHeight = Math.max(requiredHeight, this.props.ownerHeight);
-    } else {
-      contentHeight = this.state.height + this.state.maxScrollY;
-    }
-    if (contentHeight !== this._contentHeight &&
-        this.props.onContentHeightChange) {
-      this.props.onContentHeightChange(contentHeight);
-    }
-    this._contentHeight = contentHeight;
-  },
-
-  componentDidMount() {
-    this._reportContentHeight();
-  },
-
-  componentWillReceiveProps(/*object*/ nextProps) {
-    var scrollToRow = nextProps.scrollToRow;
-    if (scrollToRow !== undefined && scrollToRow !== null) {
-      this._rowToScrollTo = scrollToRow;
-    }
-    var scrollToColumn = nextProps.scrollToColumn;
-    if (scrollToColumn !== undefined && scrollToColumn !== null) {
-      this._columnToScrollTo = scrollToColumn;
-    }
-
-    var newOverflowX = nextProps.overflowX;
-    var newOverflowY = nextProps.overflowY;
-    if (newOverflowX !== this.props.overflowX ||
-        newOverflowY !== this.props.overflowY) {
-      this._wheelHandler = new ReactWheelHandler(
-        this._onWheel,
-        newOverflowX !== 'hidden', // Should handle horizontal scroll
-        newOverflowY !== 'hidden' // Should handle vertical scroll
-      );
-    }
-
-    // In the case of controlled scrolling, notify.
-    if (this.props.ownerHeight !== nextProps.ownerHeight ||
-      this.props.scrollTop !== nextProps.scrollTop) {
-      this._didScrollStart();
-    }
-    this._didScrollStop();
-
-    this.setState(this._calculateState(nextProps, this.state));
-  },
-
-  componentDidUpdate() {
-    this._reportContentHeight();
-  },
-
-  render() /*object*/ {
-    var state = this.state;
-    var props = this.props;
-
-    var groupHeader;
-    if (state.useGroupHeader) {
-      groupHeader = (
-        <FixedDataTableRow
-          key="group_header"
-          isScrolling={this._isScrolling}
-          className={joinClasses(
-            cx('fixedDataTableLayout/header'),
-            cx('public/fixedDataTable/header'),
-          )}
-          width={state.width}
-          height={state.groupHeaderHeight}
-          index={0}
-          zIndex={1}
-          offsetTop={0}
-          scrollLeft={state.scrollX}
-          fixedColumns={state.groupHeaderFixedColumns}
-          scrollableColumns={state.groupHeaderScrollableColumns}
-          onColumnResize={this._onColumnResize}
-        />
-      );
-    }
-
-    var maxScrollY = this.state.maxScrollY;
-    var showScrollbarX = state.maxScrollX > 0 && state.overflowX !== 'hidden';
-    var showScrollbarY = maxScrollY > 0 && state.overflowY !== 'hidden';
-    var scrollbarXHeight = showScrollbarX ? Scrollbar.SIZE : 0;
-    var scrollbarYHeight = state.height - scrollbarXHeight -
-        (2 * BORDER_HEIGHT) - state.footerHeight;
-
-    var headerOffsetTop = state.useGroupHeader ? state.groupHeaderHeight : 0;
-    var bodyOffsetTop = headerOffsetTop + state.headerHeight;
-    scrollbarYHeight -= bodyOffsetTop;
-    var bottomSectionOffset = 0;
-    var footOffsetTop = props.maxHeight != null
-      ? bodyOffsetTop + state.bodyHeight
-      : bodyOffsetTop + scrollbarYHeight;
-    var rowsContainerHeight = footOffsetTop + state.footerHeight;
-
-    if (props.ownerHeight !== undefined && props.ownerHeight < state.height) {
-      bottomSectionOffset = props.ownerHeight - state.height;
-
-      footOffsetTop = Math.min(
-        footOffsetTop,
-        props.ownerHeight - state.footerHeight - scrollbarXHeight
-      );
-
-      scrollbarYHeight = Math.max(0, footOffsetTop - bodyOffsetTop);
-    }
-
-    var verticalScrollbar;
-    if (showScrollbarY) {
-      verticalScrollbar =
-        <Scrollbar
-          size={scrollbarYHeight}
-          contentSize={scrollbarYHeight + maxScrollY}
-          onScroll={this._onVerticalScroll}
-          verticalTop={bodyOffsetTop}
-          position={state.scrollY}
-        />;
-    }
-
-    var horizontalScrollbar;
-    if (showScrollbarX) {
-      var scrollbarXWidth = state.width;
-      horizontalScrollbar =
-        <HorizontalScrollbar
-          contentSize={scrollbarXWidth + state.maxScrollX}
-          offset={bottomSectionOffset}
-          onScroll={this._onHorizontalScroll}
-          position={state.scrollX}
-          size={scrollbarXWidth}
-        />;
-    }
-
-    var dragKnob =
-      <FixedDataTableColumnResizeHandle
-        height={state.height}
-        initialWidth={state.columnResizingData.width || 0}
-        minWidth={state.columnResizingData.minWidth || 0}
-        maxWidth={state.columnResizingData.maxWidth || Number.MAX_VALUE}
-        visible={!!state.isColumnResizing}
-        leftOffset={state.columnResizingData.left || 0}
-        knobHeight={state.headerHeight}
-        initialEvent={state.columnResizingData.initialEvent}
-        onColumnResizeEnd={props.onColumnResizeEndCallback}
-        columnKey={state.columnResizingData.key}
-      />;
-
-    var footer = null;
-    if (state.footerHeight) {
-      footer =
-        <FixedDataTableRow
-          key="footer"
-          isScrolling={this._isScrolling}
-          className={joinClasses(
-            cx('fixedDataTableLayout/footer'),
-            cx('public/fixedDataTable/footer'),
-          )}
-          width={state.width}
-          height={state.footerHeight}
-          index={-1}
-          zIndex={1}
-          offsetTop={footOffsetTop}
-          fixedColumns={state.footFixedColumns}
-          scrollableColumns={state.footScrollableColumns}
-          scrollLeft={state.scrollX}
-        />;
-    }
-
-    var rows = this._renderRows(bodyOffsetTop);
-
-    var header =
-      <FixedDataTableRow
-        key="header"
-        isScrolling={this._isScrolling}
-        className={joinClasses(
-          cx('fixedDataTableLayout/header'),
-          cx('public/fixedDataTable/header'),
-        )}
-        width={state.width}
-        height={state.headerHeight}
-        index={-1}
-        zIndex={1}
-        offsetTop={headerOffsetTop}
-        scrollLeft={state.scrollX}
-        fixedColumns={state.headFixedColumns}
-        scrollableColumns={state.headScrollableColumns}
-        onColumnResize={this._onColumnResize}
-      />;
-
-    var topShadow;
-    var bottomShadow;
-    if (state.scrollY) {
-      topShadow =
-        <div
-          className={joinClasses(
-            cx('fixedDataTableLayout/topShadow'),
-            cx('public/fixedDataTable/topShadow'),
-          )}
-          style={{top: bodyOffsetTop}}
-        />;
-    }
-
-    if (
-      (state.ownerHeight != null &&
-        state.ownerHeight < state.height &&
-        state.scrollContentHeight + state.reservedHeight > state.ownerHeight) ||
-      state.scrollY < maxScrollY
-    ) {
-      bottomShadow =
-        <div
-          className={joinClasses(
-            cx('fixedDataTableLayout/bottomShadow'),
-            cx('public/fixedDataTable/bottomShadow'),
-          )}
-          style={{top: footOffsetTop}}
-        />;
-    }
-
-    return (
-      <div
-        className={joinClasses(
-          cx('fixedDataTableLayout/main'),
-          cx('public/fixedDataTable/main'),
-        )}
-        onWheel={this._wheelHandler.onWheel}
-        style={{height: state.height, width: state.width}}>
-        <div
-          className={cx('fixedDataTableLayout/rowsContainer')}
-          style={{height: rowsContainerHeight, width: state.width}}>
-          {dragKnob}
-          {groupHeader}
-          {header}
-          {rows}
-          {footer}
-          {topShadow}
-          {bottomShadow}
-        </div>
-        {verticalScrollbar}
-        {horizontalScrollbar}
-      </div>
-    );
-  },
-
-  _renderRows(/*number*/ offsetTop) /*object*/ {
-    var state = this.state;
-
-    return (
-      <FixedDataTableBufferedRows
-        isScrolling={this._isScrolling}
-        defaultRowHeight={state.rowHeight}
-        firstRowIndex={state.firstRowIndex}
-        firstRowOffset={state.firstRowOffset}
-        fixedColumns={state.bodyFixedColumns}
-        height={state.bodyHeight}
-        offsetTop={offsetTop}
-        onRowClick={state.onRowClick}
-        onRowDoubleClick={state.onRowDoubleClick}
-        onRowMouseDown={state.onRowMouseDown}
-        onRowMouseEnter={state.onRowMouseEnter}
-        onRowMouseLeave={state.onRowMouseLeave}
-        rowClassNameGetter={state.rowClassNameGetter}
-        rowsCount={state.rowsCount}
-        rowGetter={state.rowGetter}
-        rowHeightGetter={state.rowHeightGetter}
-        scrollLeft={state.scrollX}
-        scrollableColumns={state.bodyScrollableColumns}
-        showLastRowBorder={true}
-        width={state.width}
-        rowPositionGetter={this._scrollHelper.getRowPosition}
-      />
-    );
-  },
-
-  /**
-   * This is called when a cell that is in the header of a column has its
-   * resizer knob clicked on. It displays the resizer and puts in the correct
-   * location on the table.
-   */
-  _onColumnResize(
-    /*number*/ combinedWidth,
-    /*number*/ leftOffset,
-    /*number*/ cellWidth,
-    /*?number*/ cellMinWidth,
-    /*?number*/ cellMaxWidth,
-    /*number|string*/ columnKey,
-    /*object*/ event
-  ) {
-    this.setState({
-      isColumnResizing: true,
-      columnResizingData: {
-        left: leftOffset + combinedWidth - cellWidth,
-        width: cellWidth,
-        minWidth: cellMinWidth,
-        maxWidth: cellMaxWidth,
-        initialEvent: {
-          clientX: event.clientX,
-          clientY: event.clientY,
-          preventDefault: emptyFunction
-        },
-        key: columnKey
-      }
-    });
-  },
-
-  _areColumnSettingsIdentical(
-    oldColumns: Array,
-    newColumns: Array
-  ): boolean {
-    if (oldColumns.length !== newColumns.length) {
-      return false;
-    }
-    for (var index = 0; index < oldColumns.length; ++index) {
-      if (!shallowEqual(
-          oldColumns[index].props,
-          newColumns[index].props
-      )) {
-        return false;
-      }
-    }
-    return true;
-  },
-
-  _populateColumnsAndColumnData(
-    columns: Array,
-    columnGroups: ?Array,
-    oldState: ?Object
-  ): Object {
-    var canReuseColumnSettings = false;
-    var canReuseColumnGroupSettings = false;
-
-    if (oldState && oldState.columns) {
-      canReuseColumnSettings =
-        this._areColumnSettingsIdentical(columns, oldState.columns);
-    }
-    if (oldState && oldState.columnGroups && columnGroups) {
-      canReuseColumnGroupSettings =
-        this._areColumnSettingsIdentical(columnGroups, oldState.columnGroups);
-    }
-
-    var columnInfo = {};
-    if (canReuseColumnSettings) {
-      columnInfo.bodyFixedColumns = oldState.bodyFixedColumns;
-      columnInfo.bodyScrollableColumns = oldState.bodyScrollableColumns;
-      columnInfo.headFixedColumns = oldState.headFixedColumns;
-      columnInfo.headScrollableColumns = oldState.headScrollableColumns;
-      columnInfo.footFixedColumns = oldState.footFixedColumns;
-      columnInfo.footScrollableColumns = oldState.footScrollableColumns;
-    } else {
-      var bodyColumnTypes = this._splitColumnTypes(columns);
-      columnInfo.bodyFixedColumns = bodyColumnTypes.fixed;
-      columnInfo.bodyScrollableColumns = bodyColumnTypes.scrollable;
-
-      var headColumnTypes = this._splitColumnTypes(
-        this._selectColumnElement(HEADER, columns)
-      );
-      columnInfo.headFixedColumns = headColumnTypes.fixed;
-      columnInfo.headScrollableColumns = headColumnTypes.scrollable;
-
-      var footColumnTypes = this._splitColumnTypes(
-        this._selectColumnElement(FOOTER, columns)
-      );
-      columnInfo.footFixedColumns = footColumnTypes.fixed;
-      columnInfo.footScrollableColumns = footColumnTypes.scrollable;
-    }
-
-    if (canReuseColumnGroupSettings) {
-      columnInfo.groupHeaderFixedColumns = oldState.groupHeaderFixedColumns;
-      columnInfo.groupHeaderScrollableColumns =
-        oldState.groupHeaderScrollableColumns;
-    } else {
-      if (columnGroups) {
-        var groupHeaderColumnTypes = this._splitColumnTypes(
-          this._selectColumnElement(HEADER, columnGroups)
-        );
-        columnInfo.groupHeaderFixedColumns = groupHeaderColumnTypes.fixed;
-        columnInfo.groupHeaderScrollableColumns =
-          groupHeaderColumnTypes.scrollable;
-      }
-    }
-
-    return columnInfo;
-  },
-
-  _calculateState(/*object*/ props, /*?object*/ oldState) /*object*/ {
-    invariant(
-      props.height !== undefined || props.maxHeight !== undefined,
-      'You must set either a height or a maxHeight'
-    );
-
-    var children = [];
-    ReactChildren.forEach(props.children, (child, index) => {
-      if (child == null) {
-        return;
-      }
-      invariant(
-        child.type.__TableColumnGroup__ ||
-        child.type.__TableColumn__,
-        'child type should be <FixedDataTableColumn /> or ' +
-        '<FixedDataTableColumnGroup />'
-      );
-      children.push(child);
-    });
-
-    var useGroupHeader = false;
-    if (children.length && children[0].type.__TableColumnGroup__) {
-      useGroupHeader = true;
-    }
-
-    var firstRowIndex = (oldState && oldState.firstRowIndex) || 0;
-    var firstRowOffset = (oldState && oldState.firstRowOffset) || 0;
-    var scrollX, scrollY;
-    if (oldState && props.overflowX !== 'hidden') {
-      scrollX = oldState.scrollX;
-    } else {
-      scrollX = props.scrollLeft;
-    }
-    if (oldState && props.overflowY !== 'hidden') {
-      scrollY = oldState.scrollY;
-    } else {
-      scrollState = this._scrollHelper.scrollTo(props.scrollTop);
-      firstRowIndex = scrollState.index;
-      firstRowOffset = scrollState.offset;
-      scrollY = scrollState.position;
-    }
-
-    if (this._rowToScrollTo !== undefined) {
-      scrollState =
-        this._scrollHelper.scrollRowIntoView(this._rowToScrollTo);
-      firstRowIndex = scrollState.index;
-      firstRowOffset = scrollState.offset;
-      scrollY = scrollState.position;
-      delete this._rowToScrollTo;
-    }
-
-    var groupHeaderHeight = useGroupHeader ? props.groupHeaderHeight : 0;
-
-    if (oldState && props.rowsCount !== oldState.rowsCount) {
-      // Number of rows changed, try to scroll to the row from before the
-      // change
-      var viewportHeight =
-        (props.height === undefined ? props.maxHeight : props.height) -
-        (props.headerHeight || 0) -
-        (props.footerHeight || 0) -
-        (props.groupHeaderHeight || 0);
-      this._scrollHelper = new FixedDataTableScrollHelper(
-        props.rowsCount,
-        props.rowHeight,
-        viewportHeight,
-        props.rowHeightGetter
-      );
-      var scrollState =
-        this._scrollHelper.scrollToRow(firstRowIndex, firstRowOffset);
-      firstRowIndex = scrollState.index;
-      firstRowOffset = scrollState.offset;
-      scrollY = scrollState.position;
-    } else if (oldState && props.rowHeightGetter !== oldState.rowHeightGetter) {
-      this._scrollHelper.setRowHeightGetter(props.rowHeightGetter);
-    }
-
-    var columnResizingData;
-    if (props.isColumnResizing) {
-      columnResizingData = oldState && oldState.columnResizingData;
-    } else {
-      columnResizingData = EMPTY_OBJECT;
-    }
-
-    var columns;
-    var columnGroups;
-
-    if (useGroupHeader) {
-      var columnGroupSettings =
-        FixedDataTableWidthHelper.adjustColumnGroupWidths(
-          children,
-          props.width
-      );
-      columns = columnGroupSettings.columns;
-      columnGroups = columnGroupSettings.columnGroups;
-    } else {
-      columns = FixedDataTableWidthHelper.adjustColumnWidths(
-        children,
-        props.width
-      );
-    }
-
-    var columnInfo = this._populateColumnsAndColumnData(
-      columns,
-      columnGroups,
-      oldState
-    );
-
-    if (this._columnToScrollTo !== undefined) {
-      // If selected column is a fixed column, don't scroll
-      var fixedColumnsCount = columnInfo.bodyFixedColumns.length;
-      if (this._columnToScrollTo >= fixedColumnsCount) {
-        var totalFixedColumnsWidth = 0;
-        var i, column;
-        for (i = 0; i < columnInfo.bodyFixedColumns.length; ++i) {
-          column = columnInfo.bodyFixedColumns[i];
-          totalFixedColumnsWidth += column.props.width;
-        }
-
-        var scrollableColumnIndex = Math.min(
-          this._columnToScrollTo - fixedColumnsCount,
-          columnInfo.bodyScrollableColumns.length - 1,
-        );
-
-        var previousColumnsWidth = 0;
-        for (i = 0; i < scrollableColumnIndex; ++i) {
-          column = columnInfo.bodyScrollableColumns[i];
-          previousColumnsWidth += column.props.width;
-        }
-
-        var availableScrollWidth = props.width - totalFixedColumnsWidth;
-        var selectedColumnWidth = columnInfo.bodyScrollableColumns[
-          scrollableColumnIndex
-        ].props.width;
-        var minAcceptableScrollPosition =
-          previousColumnsWidth + selectedColumnWidth - availableScrollWidth;
-
-        if (scrollX < minAcceptableScrollPosition) {
-          scrollX = minAcceptableScrollPosition;
-        }
-
-        if (scrollX > previousColumnsWidth) {
-          scrollX = previousColumnsWidth;
-        }
-      }
-      delete this._columnToScrollTo;
-    }
-
-    var useMaxHeight = props.height === undefined;
-    var height = Math.round(useMaxHeight ? props.maxHeight : props.height);
-    var totalHeightReserved = props.footerHeight + props.headerHeight +
-      groupHeaderHeight + 2 * BORDER_HEIGHT;
-    var bodyHeight = height - totalHeightReserved;
-    var scrollContentHeight = this._scrollHelper.getContentHeight();
-    var totalHeightNeeded = scrollContentHeight + totalHeightReserved;
-    var scrollContentWidth =
-      FixedDataTableWidthHelper.getTotalWidth(columns);
-
-    var horizontalScrollbarVisible = scrollContentWidth > props.width &&
-      props.overflowX !== 'hidden';
-
-    if (horizontalScrollbarVisible) {
-      bodyHeight -= Scrollbar.SIZE;
-      totalHeightNeeded += Scrollbar.SIZE;
-      totalHeightReserved += Scrollbar.SIZE;
-    }
-
-    var maxScrollX = Math.max(0, scrollContentWidth - props.width);
-    var maxScrollY = Math.max(0, scrollContentHeight - bodyHeight);
-    scrollX = Math.min(scrollX, maxScrollX);
-    scrollY = Math.min(scrollY, maxScrollY);
-
-    if (!maxScrollY) {
-      // no vertical scrollbar necessary, use the totals we tracked so we
-      // can shrink-to-fit vertically
-      if (useMaxHeight) {
-        height = totalHeightNeeded;
-      }
-      bodyHeight = totalHeightNeeded - totalHeightReserved;
-    }
-
-    this._scrollHelper.setViewportHeight(bodyHeight);
-
-    // The order of elements in this object metters and bringing bodyHeight,
-    // height or useGroupHeader to the top can break various features
-    var newState = {
-      isColumnResizing: oldState && oldState.isColumnResizing,
-      // isColumnResizing should be overwritten by value from props if
-      // avaialble
-
-      ...columnInfo,
-      ...props,
-
-      columns,
-      columnGroups,
-      columnResizingData,
-      firstRowIndex,
-      firstRowOffset,
-      horizontalScrollbarVisible,
-      maxScrollX,
-      maxScrollY,
-      reservedHeight: totalHeightReserved,
-      scrollContentHeight,
-      scrollX,
-      scrollY,
-
-      // These properties may overwrite properties defined in
-      // columnInfo and props
-      bodyHeight,
-      height,
-      groupHeaderHeight,
-      useGroupHeader,
-    };
-
-    return newState;
-  },
-
-  _selectColumnElement(/*string*/ type, /*array*/ columns) /*array*/ {
-    var newColumns = [];
-    for (var i = 0; i < columns.length; ++i) {
-      var column = columns[i];
-      newColumns.push(React.cloneElement(
-        column,
-        {
-          cell: type ?  column.props[type] : column.props[CELL]
-        }
-      ));
-    }
-    return newColumns;
-  },
-
-  _splitColumnTypes(/*array*/ columns) /*object*/ {
-    var fixedColumns = [];
-    var scrollableColumns = [];
-    for (var i = 0; i < columns.length; ++i) {
-      if (columns[i].props.fixed) {
-        fixedColumns.push(columns[i]);
-      } else {
-        scrollableColumns.push(columns[i]);
-      }
-    }
-    return {
-      fixed: fixedColumns,
-      scrollable: scrollableColumns,
-    };
-  },
-
-  _onWheel(/*number*/ deltaX, /*number*/ deltaY) {
-    if (this.isMounted()) {
-      if (!this._isScrolling) {
-        this._didScrollStart();
-      }
-      var x = this.state.scrollX;
-      if (Math.abs(deltaY) > Math.abs(deltaX) &&
-          this.props.overflowY !== 'hidden') {
-        var scrollState = this._scrollHelper.scrollBy(Math.round(deltaY));
-        var maxScrollY = Math.max(
-          0,
-          scrollState.contentHeight - this.state.bodyHeight
-        );
-        this.setState({
-          firstRowIndex: scrollState.index,
-          firstRowOffset: scrollState.offset,
-          scrollY: scrollState.position,
-          scrollContentHeight: scrollState.contentHeight,
-          maxScrollY: maxScrollY,
-        });
-      } else if (deltaX && this.props.overflowX !== 'hidden') {
-        x += deltaX;
-        x = x < 0 ? 0 : x;
-        x = x > this.state.maxScrollX ? this.state.maxScrollX : x;
-        this.setState({
-          scrollX: x,
-        });
-      }
-
-      this._didScrollStop();
-    }
-  },
-
-
-  _onHorizontalScroll(/*number*/ scrollPos) {
-    if (this.isMounted() && scrollPos !== this.state.scrollX) {
-      if (!this._isScrolling) {
-        this._didScrollStart();
-      }
-      this.setState({
-        scrollX: scrollPos,
-      });
-      this._didScrollStop();
-    }
-  },
-
-  _onVerticalScroll(/*number*/ scrollPos) {
-    if (this.isMounted() && scrollPos !== this.state.scrollY) {
-      if (!this._isScrolling) {
-        this._didScrollStart();
-      }
-      var scrollState = this._scrollHelper.scrollTo(Math.round(scrollPos));
-      this.setState({
-        firstRowIndex: scrollState.index,
-        firstRowOffset: scrollState.offset,
-        scrollY: scrollState.position,
-        scrollContentHeight: scrollState.contentHeight,
-      });
-      this._didScrollStop();
-    }
-  },
-
-  _didScrollStart() {
-    if (this.isMounted() && !this._isScrolling) {
-      this._isScrolling = true;
-      if (this.props.onScrollStart) {
-        this.props.onScrollStart(this.state.scrollX, this.state.scrollY);
-      }
-    }
-  },
-
-  _didScrollStop() {
-    if (this.isMounted() && this._isScrolling) {
-      this._isScrolling = false;
-      this.setState({redraw: true});
-      if (this.props.onScrollEnd) {
-        this.props.onScrollEnd(this.state.scrollX, this.state.scrollY);
-      }
-    }
-  },
-});
-
-var HorizontalScrollbar = React.createClass({
-  mixins: [ReactComponentWithPureRenderMixin],
-  propTypes: {
-    contentSize: PropTypes.number.isRequired,
-    offset: PropTypes.number.isRequired,
-    onScroll: PropTypes.func.isRequired,
-    position: PropTypes.number.isRequired,
-    size: PropTypes.number.isRequired,
-  },
-
-  render() /*object*/ {
-    var outerContainerStyle = {
-      height: Scrollbar.SIZE,
-      width: this.props.size,
-    };
-    var innerContainerStyle = {
-      height: Scrollbar.SIZE,
-      position: 'absolute',
-      overflow: 'hidden',
-      width: this.props.size,
-    };
-    translateDOMPositionXY(
-      innerContainerStyle,
-      0,
-      this.props.offset
-    );
-
-    return (
-      <div
-        className={joinClasses(
-          cx('fixedDataTableLayout/horizontalScrollbar'),
-          cx('public/fixedDataTable/horizontalScrollbar'),
-        )}
-        style={outerContainerStyle}>
-        <div style={innerContainerStyle}>
-          <Scrollbar
-            {...this.props}
-            isOpaque={true}
-            orientation="horizontal"
-            offset={undefined}
-          />
-        </div>
-      </div>
-    );
-  },
-});
-
-module.exports = FixedDataTable;
diff --git a/src/transition/FixedDataTable.react.js b/src/transition/FixedDataTable.react.js
deleted file mode 100644
index de768dd..0000000
--- a/src/transition/FixedDataTable.react.js
+++ /dev/null
@@ -1,561 +0,0 @@
-/**
- * Copyright (c) 2015, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- *
- * @providesModule FixedDataTable.react
- */
-
- /**
-  * TRANSITION SHIM
-  * This acts to provide an intermediate mapping from the old API to the new API
-  *
-  * Remove this entire file and replace the two lines in FixedDataTableRoot
-  * when ready to continue to the new API.
-  */
-
-'use strict';
-
-var React = require('React');
-
-var ReactChildren = React.Children;
-
-var {PropTypes} = React;
-
-// New Table API
-var Table = require('FixedDataTableNew.react');
-var Column = require('FixedDataTableColumnNew.react');
-var ColumnGroup = require('FixedDataTableColumnGroupNew.react');
-
-// Transition Cell
-var TransitionCell = require('FixedDataTableCellTransition.react');
-
-var NEXT_VERSION = '0.7.0';
-var DOCUMENTATION_URL = 'https://fburl.com/FixedDataTable-v0.6';
-
-var EMPTY_OBJECT = {};
-
-/**
- * Notify in console that some prop has been deprecated.
- */
-var notified = {};
-function notifyDeprecated(prop, reason) {
-  if (__DEV__) {
-    if (!notified[prop]) {
-      console.warn(
-        '`' + prop + '` will be DEPRECATED in version ' +
-        NEXT_VERSION + ' of FixedDataTable and beyond. \n' +
-        reason + '\n' +
-        'Read the docs at: ' + DOCUMENTATION_URL
-      );
-      notified[prop] = true;
-    }
-  }
-}
-
-/**
- * Data grid component with fixed or scrollable header and columns.
- *
- * This is currently in a transition mode, as the new API is used.
- * DEPRECATED endpoints work, but will not be supported in later versions.
- *
- * The layout of the data table is as follows:
- *
- * ```
- * +---------------------------------------------------+
- * | Fixed Column Group    | Scrollable Column Group   |
- * | Header                | Header                    |
- * |                       |                           |
- * +---------------------------------------------------+
- * |                       |                           |
- * | Fixed Header Columns  | Scrollable Header Columns |
- * |                       |                           |
- * +-----------------------+---------------------------+
- * |                       |                           |
- * | Fixed Body Columns    | Scrollable Body Columns   |
- * |                       |                           |
- * +-----------------------+---------------------------+
- * |                       |                           |
- * | Fixed Footer Columns  | Scrollable Footer Columns |
- * |                       |                           |
- * +-----------------------+---------------------------+
- * ```
- *
- * - Fixed Column Group Header: These are the headers for a group
- *   of columns if included in the table that do not scroll
- *   vertically or horizontally.
- *
- * - Scrollable Column Group Header: The header for a group of columns
- *   that do not move while scrolling vertically, but move horizontally
- *   with the horizontal scrolling.
- *
- * - Fixed Header Columns: The header columns that do not move while scrolling
- *   vertically or horizontally.
- *
- * - Scrollable Header Columns: The header columns that do not move
- *   while scrolling vertically, but move horizontally with the horizontal
- *   scrolling.
- *
- * - Fixed Body Columns: The body columns that do not move while scrolling
- *   horizontally, but move vertically with the vertical scrolling.
- *
- * - Scrollable Body Columns: The body columns that move while scrolling
- *   vertically or horizontally.
- */
-var TransitionTable = React.createClass({
-  propTypes: {
-    /**
-     * Pixel width of table. If all columns do not fit,
-     * a horizontal scrollbar will appear.
-     */
-    width: PropTypes.number.isRequired,
-
-    /**
-     * Pixel height of table. If all rows do not fit,
-     * a vertical scrollbar will appear.
-     *
-     * Either `height` or `maxHeight` must be specified.
-     */
-    height: PropTypes.number,
-
-    /**
-     * Maximum pixel height of table. If all rows do not fit,
-     * a vertical scrollbar will appear.
-     *
-     * Either `height` or `maxHeight` must be specified.
-     */
-    maxHeight: PropTypes.number,
-
-    /**
-     * Pixel height of table's owner, this is used in a managed scrolling
-     * situation when you want to slide the table up from below the fold
-     * without having to constantly update the height on every scroll tick.
-     * Instead, vary this property on scroll. By using `ownerHeight`, we
-     * over-render the table while making sure the footer and horizontal
-     * scrollbar of the table are visible when the current space for the table
-     * in view is smaller than the final, over-flowing height of table. It
-     * allows us to avoid resizing and reflowing table when it is moving in the
-     * view.
-     *
-     * This is used if `ownerHeight < height` (or `maxHeight`).
-     */
-    ownerHeight: PropTypes.number,
-
-    overflowX: PropTypes.oneOf(['hidden', 'auto']),
-    overflowY: PropTypes.oneOf(['hidden', 'auto']),
-
-    /**
-     * Number of rows in the table.
-     */
-    rowsCount: PropTypes.number.isRequired,
-
-    /**
-     * Pixel height of rows unless `rowHeightGetter` is specified and returns
-     * different value.
-     */
-    rowHeight: PropTypes.number.isRequired,
-
-    /**
-     * If specified, `rowHeightGetter(index)` is called for each row and the
-     * returned value overrides `rowHeight` for particular row.
-     */
-    rowHeightGetter: PropTypes.func,
-
-    /**
-     * DEPRECATED
-     *
-     * To get rows to display in table, `rowGetter(index)`
-     * is called. `rowGetter` should be smart enough to handle async
-     * fetching of data and return temporary objects
-     * while data is being fetched.
-     */
-    rowGetter: PropTypes.func,
-
-    /**
-     * To get any additional CSS classes that should be added to a row,
-     * `rowClassNameGetter(index)` is called.
-     */
-    rowClassNameGetter: PropTypes.func,
-
-    /**
-     * Pixel height of the column group header.
-     */
-    groupHeaderHeight: PropTypes.number,
-
-    /**
-     * Pixel height of header.
-     */
-    headerHeight: PropTypes.number.isRequired,
-
-    /**
-     * DEPRECATED
-     *
-     * Function that is called to get the data for the header row.
-     * If the function returns null, the header will be set to the
-     * Column's label property.
-     */
-    headerDataGetter: PropTypes.func,
-
-    /**
-     * Pixel height of footer.
-     */
-    footerHeight: PropTypes.number,
-
-    /**
-     * DEPRECATED - use footerDataGetter instead.
-     * Data that will be passed to footer cell renderers.
-     */
-    footerData: PropTypes.oneOfType([
-      PropTypes.object,
-      PropTypes.array,
-    ]),
-
-    /**
-     * DEPRECATED
-     *
-     * Function that is called to get the data for the footer row.
-     */
-    footerDataGetter: PropTypes.func,
-
-    /**
-     * Value of horizontal scroll.
-     */
-    scrollLeft: PropTypes.number,
-
-    /**
-     * Index of column to scroll to.
-     */
-    scrollToColumn: PropTypes.number,
-
-    /**
-     * Value of vertical scroll.
-     */
-    scrollTop: PropTypes.number,
-
-    /**
-     * Index of row to scroll to.
-     */
-    scrollToRow: PropTypes.number,
-
-    /**
-     * Callback that is called when scrolling starts with current horizontal
-     * and vertical scroll values.
-     */
-    onScrollStart: PropTypes.func,
-
-    /**
-     * Callback that is called when scrolling ends or stops with new horizontal
-     * and vertical scroll values.
-     */
-    onScrollEnd: PropTypes.func,
-
-    /**
-     * Callback that is called when `rowHeightGetter` returns a different height
-     * for a row than the `rowHeight` prop. This is necessary because initially
-     * table estimates heights of some parts of the content.
-     */
-    onContentHeightChange: PropTypes.func,
-
-    /**
-     * Callback that is called when a row is clicked.
-     */
-    onRowClick: PropTypes.func,
-
-    /**
-     * Callback that is called when a row is double clicked.
-     */
-    onRowDoubleClick: PropTypes.func,
-
-    /**
-     * Callback that is called when a mouse-down event happens on a row.
-     */
-    onRowMouseDown: PropTypes.func,
-
-    /**
-     * Callback that is called when a mouse-enter event happens on a row.
-     */
-    onRowMouseEnter: PropTypes.func,
-
-    /**
-     * Callback that is called when a mouse-leave event happens on a row.
-     */
-    onRowMouseLeave: PropTypes.func,
-
-    /**
-     * Callback that is called when resizer has been released
-     * and column needs to be updated.
-     *
-     * Required if the isResizable property is true on any column.
-     *
-     * ```
-     * function(
-     *   newColumnWidth: number,
-     *   dataKey: string,
-     * )
-     * ```
-     */
-    onColumnResizeEndCallback: PropTypes.func,
-
-    /**
-     * Whether a column is currently being resized.
-     */
-    isColumnResizing: PropTypes.bool,
-  },
-
-  getInitialState() {
-    // Throw warnings on deprecated props.
-    var state = {};
-    state.needsMigration = this._checkDeprecations();
-
-    return state;
-  },
-
-  _checkDeprecations() {
-    var needsMigration = false;
-
-    if (this.props.rowGetter) {
-      notifyDeprecated('rowGetter',
-        'Please use the cell API in Column to fetch data for your cells.'
-      );
-
-      // ROWGETTER??? You need to migrate.
-      needsMigration = true;
-    }
-
-    if (this.props.headerDataGetter) {
-      notifyDeprecated('headerDataGetter',
-        'Please use the header API in Column to ' +
-        'fetch data for your header cells.'
-      );
-    }
-
-    if (this.props.footerData) {
-      notifyDeprecated('footerData',
-        'Please use the footer API in Column to ' +
-        'fetch data for your footer cells.'
-      );
-    }
-
-    if (this.props.footerDataGetter) {
-      notifyDeprecated('footerDataGetter',
-        'Please use the footer API in Column to ' +
-        'fetch data for your footer cells.'
-      );
-    }
-
-    ReactChildren.forEach(this.props.children, (child) => {
-      if (!child || !child.props) {
-        return;
-      }
-
-      var props = child.props;
-
-      if (props.label) {
-        notifyDeprecated('label',
-          'Please use `header` instead.'
-        );
-      }
-
-      if (props.dataKey) {
-        notifyDeprecated('dataKey',
-          'Please use the `cell` API to pass in a dataKey'
-        );
-      }
-
-      if (props.cellRenderer) {
-        notifyDeprecated('cellRenderer',
-          'Please use the `cell` API to pass in a React Element instead.'
-        );
-      }
-
-      if (props.headerRenderer) {
-        notifyDeprecated('headerRenderer',
-          'Please use the `header` API to pass in a React Element instead.'
-        );
-      }
-
-      if (props.columnData) {
-        notifyDeprecated('columnData',
-          'Please pass data in through props to your header, cell or footer.'
-        );
-      }
-
-      if (props.groupHeaderRenderer) {
-        notifyDeprecated('groupHeaderRenderer',
-          'Please use the `header` API in ColumnGroup to ' +
-          'pass in a React Element instead of a function that creates one.'
-        );
-      }
-
-      if (props.groupHeaderData) {
-        notifyDeprecated('groupHeaderData',
-          'Please pass in any data through props to your header.'
-        );
-      }
-    });
-
-    return needsMigration;
-  },
-
-  // Wrapper for onRow callbacks, since we don't have rowData at that level.
-  _onRowAction(props, callback) {
-    if (!callback) {
-      return undefined;
-    }
-
-    return (e, rowIndex) => {
-      callback(
-        e,
-        rowIndex,
-        (props.rowGetter && props.rowGetter(rowIndex)) || EMPTY_OBJECT
-      );
-    };
-  },
-
-  _transformColumn(column, tableProps, key) {
-
-    var props = column.props;
-
-    if (column.type.__TableColumn__) {
-      // Constuct the cell to be used using the rowGetter
-      return (
-        <Column
-          key={'column_' + key}
-          {...props}
-          header={
-            <TransitionCell
-              isHeaderCell={true}
-              label={props.label}
-              width={props.width}
-              dataKey={props.dataKey}
-              className={props.headerClassName}
-              columnData={props.columnData || EMPTY_OBJECT}
-              cellRenderer={props.headerRenderer}
-              headerDataGetter={tableProps.headerDataGetter}
-            />
-          }
-          columnKey={props.dataKey}
-          cell={
-            <TransitionCell
-              dataKey={props.dataKey}
-              className={props.cellClassName}
-              rowGetter={tableProps.rowGetter}
-              width={props.width}
-              columnData={props.columnData || EMPTY_OBJECT}
-              cellDataGetter={props.cellDataGetter}
-              cellRenderer={props.cellRenderer}
-            />
-          }
-          footer={
-            <TransitionCell
-              isFooterCell={true}
-              className={props.footerClassName}
-              dataKey={props.dataKey}
-              cellRenderer={props.footerRenderer}
-              footerDataGetter={tableProps.footerDataGetter}
-              footerData={tableProps.footerData || EMPTY_OBJECT}
-            />
-          }
-        />
-      );
-    }
-  },
-
-  _transformColumnGroup(group, tableProps, key, labels) {
-    var props = group.props;
-
-    var j = 0;
-    var columns = ReactChildren.map(props.children, (child) => {
-      j++;
-      return this._transformColumn(child, tableProps, key + '_' + j);
-    });
-
-    return (
-      <ColumnGroup
-        {...props}
-        key={'group_' + key}
-        header={
-          <TransitionCell
-            isHeaderCell={true}
-            label={group.props.label}
-            dataKey={key}
-            groupHeaderRenderer={props.groupHeaderRenderer}
-            groupHeaderLabels={labels}
-            groupHeaderData={props.columnGroupData || EMPTY_OBJECT}
-          />
-        }>
-        {columns}
-      </ColumnGroup>
-    );
-  },
-
-  _convertedColumns(needsMigration) {
-    // If we don't need to migrate, map directly to the new API.
-    if (!needsMigration) {
-      return ReactChildren.map(this.props.children, (child) => {
-
-        if (!child) {
-          return null;
-        }
-
-        if (child.type.__TableColumn__) {
-          return <Column {...child.props} />;
-        }
-
-        if (child.type.__TableColumnGroup__) {
-          return <ColumnGroup {...child.props} />;
-        }
-      });
-    }
-
-    var tableProps = this.props;
-
-    // Otherwise, if a migration is needed, we need to transform each Column
-    // or ColumnGroup.
-    var i = 0;
-    return ReactChildren.map(this.props.children, (child) => {
-
-      if (!child) {
-        return null;
-      }
-
-      if (child.type.__TableColumn__) {
-        child = this._transformColumn(child, tableProps, i);
-      }
-
-      if (child.type.__TableColumnGroup__) {
-        // Since we apparently give an array of labels to groupHeaderRenderer
-        var labels = [];
-        ReactChildren.forEach(this.props.children, (child) => {
-          labels.push(child.props.label);
-        });
-
-        child = this._transformColumnGroup(child, tableProps, i, labels);
-      }
-
-      i++;
-      return child;
-    });
-  },
-
-  render() {
-    var props = this.props;
-    return (
-      <Table
-        {...props}
-        onRowMouseDown={this._onRowAction(props, props.onRowMouseDown)}
-        onRowClick={this._onRowAction(props, props.onRowClick)}
-        onRowDoubleClick={this._onRowAction(props, props.onRowDoubleClick)}
-        onRowMouseEnter={this._onRowAction(props, props.onRowMouseEnter)}
-        onRowMouseLeave={this._onRowAction(props, props.onRowMouseLeave)}
-        >
-        {this._convertedColumns(this.state.needsMigration)}
-      </Table>
-    );
-  },
-});
-
-module.exports = TransitionTable;
diff --git a/src/transition/FixedDataTableCellTransition.react.js b/src/transition/FixedDataTableCellTransition.react.js
deleted file mode 100644
index 300c376..0000000
--- a/src/transition/FixedDataTableCellTransition.react.js
+++ /dev/null
@@ -1,219 +0,0 @@
-/**
- * Copyright (c) 2015, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- *
- * @providesModule FixedDataTableCellTransition.react
- */
-
-/**
- * TRANSITION SHIM
- * This acts to provide an intermediate mapping from the old API to the new API.
- *
- * When ready, remove this file and rename the providesModule in
- * FixedDataTableCellNew.react and dependency in FixedDataTableCellGroup.react
- */
-
-var React = require('React');
-var {PropTypes} = React;
-
-var cx = require('cx');
-var joinClasses = require('joinClasses');
-var shallowEqual = require('shallowEqual');
-
-var CellDefault = require('FixedDataTableCellDefault.react');
-
-var TransitionCell = React.createClass({
-
-  propTypes: {
-    label: PropTypes.string, // header, footer
-    className: PropTypes.string,
-    rowIndex: PropTypes.number,
-    rowGetter: PropTypes.func, // cell
-    dataKey: PropTypes.oneOfType([ // cell, footer
-      PropTypes.string,
-      PropTypes.number
-    ]),
-    cellRenderer: PropTypes.func,
-    cellDataGetter: PropTypes.func,
-    footerDataGetter: PropTypes.func, // footer
-    footerData: PropTypes.any, // footer
-    columnData: PropTypes.any, // cell, header
-    width: PropTypes.number,
-    height: PropTypes.number,
-    isHeaderCell: PropTypes.bool, // header
-    isFooterCell: PropTypes.bool, // footer
-  },
-
-  shouldComponentUpdate(/*object*/ nextProps): boolean {
-    var update = false;
-    var rowData;
-    if (nextProps.rowGetter) {
-      rowData = nextProps.rowGetter(nextProps.rowIndex);
-      if (this._rowData !== rowData) {
-        update = true;
-      }
-    }
-
-    var cellData;
-    if (nextProps.dataKey != null) {
-      if (nextProps.cellDataGetter) {
-        cellData = nextProps.cellDataGetter(nextProps.dataKey, rowData);
-      }
-      if (!cellData && rowData) {
-        cellData = rowData[nextProps.dataKey];
-      }
-    }
-    if (this._cellData !== cellData) {
-      update = true;
-    }
-    this._rowData = rowData;
-    this._cellData = cellData;
-
-    return update || !shallowEqual(nextProps, this.props);
-  },
-
-  _getCellData(props) {
-    var dataKey = props.dataKey;
-    if (dataKey == null) {
-      return null;
-    }
-
-    var rowData;
-    if (props.rowGetter) {
-      rowData = props.rowGetter(props.rowIndex);
-    }
-
-    if (props.cellDataGetter) {
-      return props.cellDataGetter(dataKey, rowData);
-    }
-
-    if (rowData) {
-      return rowData[dataKey];
-    }
-
-    if (props.footerDataGetter) {
-      return props.footerDataGetter()[dataKey];
-    }
-
-    if (props.footerData) {
-      return props.footerData[dataKey];
-    }
-
-    if (props.headerDataGetter) {
-      return props.headerDataGetter[dataKey];
-    }
-  },
-
-  _getRowData(props): Object {
-    if (props.rowGetter) {
-      return props.rowGetter(props.rowIndex) || {};
-    }
-
-    if (props.footerDataGetter) {
-      return props.footerDataGetter() || {};
-    }
-
-    if (props.footerData) {
-      return props.footerData || {};
-    }
-
-    return {};
-  },
-
-  render() {
-    var props = this.props;
-
-    var cellData = this._getCellData(props);
-    var content = cellData;
-    var rowData = this._getRowData(props);
-    var usingRenderer = !!(props.cellRenderer || props.groupHeaderRenderer);
-
-    if (props.isHeaderCell || props.isFooterCell) {
-      content = content || props.label;
-    }
-
-    if (props.cellRenderer) {
-      if (props.isHeaderCell || props.isFooterCell) {
-        content = props.cellRenderer(
-          props.label,
-          props.dataKey,
-          props.columnData,
-          rowData,
-          props.width,
-        ) || props.label;
-      } else {
-        content = props.cellRenderer(
-          cellData,
-          props.dataKey,
-          rowData,
-          props.rowIndex,
-          props.columnData,
-          props.width,
-        );
-      }
-    }
-
-    if (props.groupHeaderRenderer) {
-      content = props.groupHeaderRenderer(
-        props.label,
-        props.dataKey, // index in children
-        props.groupHeaderData,
-        props.groupHeaderLabels,
-        props.width,
-      ) || content;
-    }
-
-    var contentClass = cx('public/fixedDataTableCell/cellContent');
-
-    if (React.isValidElement(content) && usingRenderer) {
-      content = React.cloneElement(content, {
-        className: joinClasses(content.props.className, contentClass)
-      });
-    } else {
-      return (
-        <CellDefault
-          {...props}>
-          {content}
-        </CellDefault>
-      );
-    }
-
-    var innerStyle = {
-      height: props.height,
-      width: props.width,
-      ...props.style,
-    };
-
-    return (
-      <div
-        {...this.props}
-        className={joinClasses(
-          cx('fixedDataTableCellLayout/wrap1'),
-          cx('public/fixedDataTableCell/wrap1'),
-          this.props.className
-        )}
-        style={innerStyle}>
-        <div
-          className={joinClasses(
-            cx('fixedDataTableCellLayout/wrap2'),
-            cx('public/fixedDataTableCell/wrap2'),
-          )}>
-          <div
-            className={joinClasses(
-              cx('fixedDataTableCellLayout/wrap3'),
-              cx('public/fixedDataTableCell/wrap3'),
-            )}>
-            {content}
-          </div>
-        </div>
-      </div>
-    );
-
-  }
-});
-
-module.exports = TransitionCell;
diff --git a/src/transition/FixedDataTableColumn.react.js b/src/transition/FixedDataTableColumn.react.js
deleted file mode 100644
index 25f31da..0000000
--- a/src/transition/FixedDataTableColumn.react.js
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Copyright (c) 2015, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- *
- * @providesModule FixedDataTableColumn.react
- */
-
-/**
- * TRANSITION SHIM
- * This acts to provide an intermediate mapping from the old API to the new API.
- *
- * When ready, remove this file and rename the providesModule in
- * FixedDataTableColumnNew.react
- */
-
-var React = require('React');
-
-var TransitionColumn = React.createClass({
-  statics: {
-    __TableColumn__: true
-  },
-
-  render() {
-    if (__DEV__) {
-      throw new Error(
-        'Component <TransitionColumn /> should never render'
-      );
-    }
-    return null;
-  }
-});
-
-module.exports = TransitionColumn;
diff --git a/src/transition/FixedDataTableColumnGroup.react.js b/src/transition/FixedDataTableColumnGroup.react.js
deleted file mode 100644
index 911126d..0000000
--- a/src/transition/FixedDataTableColumnGroup.react.js
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Copyright (c) 2015, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- *
- * @providesModule FixedDataTableColumnGroup.react
- */
-
- /**
-  * TRANSITION SHIM
-  * This provides an intermediate mapping from the old API to the new API.
-  *
-  * When ready, remove this file and rename the providesModule in
-  * FixedDataTableColumnNew.react
-  */
-
-var React = require('React');
-
-var TransitionColumnGroup = React.createClass({
-  statics: {
-    __TableColumnGroup__: true,
-  },
-
-  render() {
-    if (__DEV__) {
-      throw new Error(
-        'Component <TransitionColumnGroup /> should never render'
-      );
-    }
-    return null;
-  }
-});
-
-module.exports = TransitionColumnGroup;
-- 
2.2.1

